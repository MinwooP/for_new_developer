# 비전공자를 위한 이해할 수 있는 IT 지식

<img src = "https://user-images.githubusercontent.com/31370590/128682892-5a51090a-8d33-40bc-a0f0-f1070c3122a7.PNG" width = "300" height = "400">

## <div align="center">목차</div>

-------

+ [Orientation](#-Orientation)
+ [프로그래밍 언어와 운영체제](#-프로그래밍-언어와-운영체제)
+ [네트워크, 클라이언트, 서버](#-네트워크,-클라이언트,-서버)
+ [API와 JSON](#-API와-JSON)
+ [Application](#-Application)
+ [Web](#-Web)
+ [데이터베이스와 이미지 처리](#-데이터베이스와-이미지-처리)
+ [프레임워크와 라이브러리](#-프레임워크와-라이브러리)

------

## 🎖 Orientation

+ IT 산업은 6개월 뒤의 모습만 예측할 수 있어도 대박이 난다고 이야기할만큼 변화의 속도가 너무나도 빠릅니다. 만약 IT 산업에서 자동차를 만들고 싶다면, 자동차의 완벽한 기획에서 출발해선 안됩니다. 왜냐하면 지금 떠올린 자동차의 모습이 6개월, 1년 뒤에도 완벽한 자동차의 모습이라고 장담할 수 없으니까요. 
+ 그래서 처음에는 이동수단이라는 '핵심기능'에 중점을 두어서 스케이트보드 형태의 자동차를 만듭니다. 이후 꼭 필요한 기능들을 붙여서 킥보드 형태로 발전시켜 나가죠. 시간이 지날수록 새로운 기술과 기능들이 탄생하게 되고, 이러한 것들을 차차 반영하여 자동차의 모습으로 만들어 나갑니다. IT 산업에서는 이런 식으로 **점진적 발전**만 있을 뿐입니다. 변화의 속도가 빠르기 때문에 처음부터 완성된 형태를 정해놓고 만드는 것은 위험한 일입니다. 
+ 대체로 다른 산업은 A~Z까지 정해진 완벽한 프로세스가 있습니다. 그 프로세스만 잘 따라가면 어려울 일이 없습니다. 하지만 IT 서비스는 그렇지 않습니다. 완벽한 프로세스가 없고, 고객의 니즈와 회사의 사정에 맞춰 그때그때 서비스가 계속 '발전'되어 나갑니다. **서비스가 발전하는 이 흐름**이 바로 **기획**입니다. 그래서 기획자는 항상 고객을 포함한 모든 서비스 구성원들과 **대화**를 해야 합니다. 따라서, IT 산업에서 일하는 기획자에게 가장 먼저 필요한 건 '파이썬'이나 '자바'가 아니라 '커뮤니케이션' 이다. 

<br>

<br>

-----

## 🎖 프로그래밍 언어와 운영체제

#### 언어

+ 컴파일러는 인간의 요구를 컴퓨터에게 전달해준다. 개발자는 컴파일러에게 문자로 일을 시키는 사람이다. 영어로 되어있는 프로그래밍 언어를 사용해 컴파일러에게 명령을 전달하면, 컴파일러가 그 명령을 기계어인 0과 1로 변환해 컴퓨터에게 전달을 하는 방식입니다.  

+ C언어가 발전해서 Objective-C, C++, 파이썬이 되었습니다. 

+ 컴퓨터 친화적인 언어(저수준)들은 배우기 쉽지 않습니다. 컴퓨터가 어떻게 일해야 하는지 구체적으로, 꼼꼼하게 적어줘야 합니다. 대신 컴퓨터 입장에서는 구체적으로 적혀있으니 일하기 쉽습니다. 따라서 **낮은 사양의 컴퓨터에도 원활히 작동합니다.**

+ 반면, 인간 친화적인 언어(고수준)들은 조금만 설명해줘도 컴퓨터가 알아서 행동합니다. 하지만 그만큼 **컴퓨터가 더 많이 고민**해야 하기 때문에 저수준 언어보다 **작동이 느립니다.** 따라서 고수준 언어는 컴퓨터의 사양에 따라 잘 작동할 수도, 그렇지 않을 수도 있습니다. 

+ 저수준 언어로 코딩하는 이유 => **컴퓨터 사양을 낮추고 싶어서**, 그래야 컴퓨터 가격이 저렴해진다. 보통 다른 메인 기능이 있는 가전제품에 컴퓨터가 들어갈 때 저수준 언어를 사용한다. 

  EX) 소비자가 IPTV를 사용하면서 고급 컴퓨터 기능을 원하는 게 아니기 때문에 IPTV 셋톱박스에 들어가는 컴퓨터 사양을 낮춰서 가격을 떨어뜨려야 한다. 이를 위해 최대한 저수준 언어를 사용해야 한다. 

<br>

#### 컴퓨터의 구성요소

+ CPU  => 머리
+ 메모리  => CPU의 개인 작업 공간 
+ 보조기억장치(HDD, SSD)  => 창고

<br>

### 운영체제

+ 운영체제는 우리 대신 하드웨어를 관리해준다.

  (ex) 하드디스크의 3번 플래터에 접근해서, 포토샵 데이터를 2번 메모리의 3번 구역에 올린 뒤 CPU에게 일을 시켜라)

+ Windows, Mac OS, IOS, Andriod

+ 마이크로소프트에서는 개발자들에게 이렇게 말한다.

  "만약 윈도우에서 돌아가는 파워포인트 같은 프로그램을 만들고 싶다면, 우리가 지정한 언어들을 써라"

  애플과 구글도 마찬가지다. 애플의 운영체제 위에서 돌아가는 프로그램을 만들려면 Objective-C 혹은 스위프트라는 언어를 사용해야 한다. 

+ 자바를 만든 팀은 *각 운영체제 위에* **JVM**이라는 소프트웨어를 만들었다. JVM 위에서 자바 언어로 만든 프로그램이 돌아갈 수 있도록 한 것이다. 사용자가 자신의 컴퓨터에 JVM을 설치하기만 하면, 운영체제별로 여러 개의 프로그램을 만들 필요 없이 자바로만 만들면 된다. 
+ 과거부터 지금까지 많은 소프트웨어가 자바 언어로 개발되었다. 이 언어로 개발한 소프트웨어들이 너무 많기 때문에 우리는 종종 정부 기관의 소프트웨어를 쓰기 위해, 또 특정 회사에서 개발한 소프트웨어를 사용하기 위해 JVM을 계속 최신 버전으로 설치해왔다. 

+ 하지만 자바나 파이썬 같은 프로그램을 사용하면, 속도가 느리다는 단점도 있다. 운영체제 위에 프로그램(JVM)을 올리고, 그 위에 또 프로그램을 돌리는 것이기 때문이다. 

<br>

<br>

-------

## 🎖 네트워크, 클라이언트, 서버

+ 카카오톡 설치 과정

  "카카오톡 설치 파일을 보내줘!"라는 신호가 가까운 기지국으로 감

  => 신호는 WAN을 따라 이동해 애플의 컴퓨터로 도착

  => 애플의 컴퓨터는 '카카오톡 설치 파일'을 우리의 컴퓨터로 보내준다. 

  => 다시 WAN을 따라 이동해 기지국을 거쳐 우리의 컴퓨터에 도착한다. 

<br>

+ IP주소 : 해당 컴퓨터가 위치한 주소로, **인터넷에 접속하는 순간 컴퓨터는 지금 위치에 맞는 IP주소를 갖게 된다.** 

<br>

+ 클라이언트 : 파일을 요청하는 컴퓨터

  서버 : 파일을 주는 컴퓨터

<br>

+ 리눅스
  + 리눅스는 운영체제로, 리눅스 위에서 '서버 프로그램'을 돌린다. 
  + 서버는 클라이언트의 요청에 응답하는 컴퓨터이고, 요청의 종류에 따라 이에 맞는 적절한 응답을 줘야 하는데, 이를 위해서는 서버 프로그램이 동작해야 하고, 하드웨어를 직접 컨트롤하지 않으려면 운영체제 위에서 프로그램을 돌려야 한다. 즉, 리눅스 위에 서버 프로그램을 돌리는 것이다. 
  + 리눅스 위에서 서버 프로그램을 돌리는 이유는, 리눅스가 기본적으로 '무료' 이기 때문이다. 리눅스의 유명한 버전 중 하나가 **우분투**이다. 리눅스는 그래픽 UI 없이 명령어로만 동작한다. 서버 프로그램은 24시간 365일 '안정적'으로 돌아가는 게 제일 중요하다. 

<br>

<br>

-------

## 🎖 API와 JSON

### API

+ 클라이언트는 서버에 요청을 보내고, 서버는 요청에 따라 적합한 처리를 해서 응답을 준다. 

  => 하지만 컴퓨터는 어떤 요청이 '메시지를 달라'는 요청인지 '로그인 시켜달라'는 요청인지 알 수 없다.

  => 이러한 **요청을 구분할 수 있는 체계**가 **API**이다. 

  => **API**는 클라이언트, 서버와 같은 서로 다른 프로그램에서 **요청과 응답을 주고 받을 수 있게** 만든 체계이다.

  => 즉, API는 서버 개발자가 개발하고, 클라이언트 개발자는 그 API를 사용한다.

+ API를 만들 때는 데이터를 주고 받는 기능도 함께 넣어준다. 로그인 요청을 할 때 아이디와 비밀번호 데이터가 필요하고 비디오 파일이나 이미지 파일에 대한 응답을 받을 때도 데이터가 함께 와야 한다. 
+ API의 진행을 보면, 응답을 주는 쪽(서버)에서 사전에 **여기로 요청을 보내면 이러한 응답을 주고, 저기로 요청을 보내면 저러한 응답을 줄께**라고 정해놔야 한다. 그래야 요청하는 쪽(클라)에서 정확한 곳에 요청을 보낼 수 있다. 
  + '정확한 곳'에 해당하는 주소는 **'서버주소/A'**의 형태로 정의되어 있다. 서버주소는 컴퓨터가 위치한 곳의 주소로 네트워크에서 언급한 IP주소이다. A에 어떤 문자를 쓰느냐에 따라 다른 기능을 수행하도록 정의하는 것이다. 

<br>

### API를 클라이언트의 관점에서 보자

+ 데이터를 다룰 때 큰 틀에서 보면 대부분의 요청이 이 **CRUD**의 4가지 요청에 속한다.

  > CRUD
  >
  > **C**reate
  >
  > **R**ead
  >
  > **U**pdate
  >
  > **D**elete

  + 예를 들어, 타임라인(ex) 페이스북)의 **CRUD 요청은 각각의 주소를 가진다.** 예를 들면 Create 요청은 '서버 컴퓨터의 주소/timelinecreate'라고 지을 수 있다. 서버의 기능을 원하는 클라이언트는 해당 주소로 요청을 보내면 된다. 

+ RESTful API

  CRUD별로 주소가 너무 많아지고 관리하기가 힘들어져 만든 좀 더 체계적인 API로 이전보다 주소 개수가 줄어들었다. **CRUD를 하나의 주소로 관리**한다. 그리고 요청을 보낼 때 다음과 같이 어떤 요청을 보냈는지 파악할 수 있는 **스티커**를 붙여서 함께 전송한다. 

  > RESTful API
  >
  > + Create(생성해줘) : POST
  > + Read(불러와줘) : GET
  > + Update(바꿔줘) : PUT(전체)/PATCH(일부)
  > + Delete(지워줘) : DELETE

  현업에서는 '스티커'를 붙인다고 말하지 않고, **메소드**라는 용어를 사용한다. 

<br>

### API를 서버의 관점에서 보자

+ 클라이언트에서 요청을 보내면, 서버는 요청에 대해 응답해야 하는데, 이 응답에는 '잘 됐어'와 '잘 안됐어' 이렇게 2개의 응답이 있을 수 있다. 
+ 각 부서에서 '잘 됐어'의 응답을 서로 다르게 준다면 그 모든 표현을 하나하나 대응할 수 있게 코드를 만들어야 하므로 곤란하다. 따라서 개발자들은 '잘 됐어'나 '잘 안됐어'에도 체계가 필요하다고 생각했다.
  + 잘 됐어 => 200번 대 코드
  + 잘 안됐어 => 400, 500번 대 코드
    + 400번대 코드 - **클라이언트의 요청**에 문제가 있는 경우(ex) 클라에서 보내주는 JSON에 필수 파라미터가 빠져있는 경우ㅍ )
    + 500번대 코드 - **서버에 문제**가 있는 경우
  
+ 또한, 응답에는 데이터가 필요할 수도 있다. 이렇게 요청과 응답에 데이터를 담아 주고 받음으로써 API 요청이 완성된다. 

+ 정리하면, API는 소프트웨어가 다른 소프트웨어의 기능을 쓰기 위해 중간에 필요한 체계이다.  

  > A 소프트웨어가 B 소프트웨어의 '한글 영어 번역기능'을 사용하고 싶다면, A 소프트웨어는 API를 사용하여 정해진 방법대로 'B소프트웨어'에 요청을 보내고, 'B소프트웨어'는 요청대로 작업을 수행하고, 응답을 준다. API는 응답을 보내는 쪽에서 만들고, 요청을 보내는 쪽은 활용할 뿐이다. 

+ **SDK**란, API를 제공해주는 다른 소프트웨어이다. (위의 예시에서 B 소프트웨어)

  EX) 구글 지도는 구글에서 만든 소프트웨어이다. 이때 다른 회사들도 구글에서 제공하는  지도 SDK를 설치하면 자신의 소프트웨어에 구글 지도 기능을 넣을 수 있다. 이 SDK에서 제공해주는 API들을 통해 구글 지도에 요청을 보낼 수 있다. 

<br>

### JSON

클라와 서버는 요청과 응답을 주고답고, 그 때 필요한 데이터들을 **JSON** 형식으로 주고받는다. 

+ JSON 형식

  ```json
  {
      "id" : "minwoo",
      "pw" : "asd456"
  }
  ```

<br>

### API 문서

+ `https://api.cakes.com/v1/cakes/:id/` 라는 주소가 있다. 앞의 `https://api.cakes.com/`는 컴퓨터가 있는 위치로, 원래 IP 주소가 들어가는 곳이다. 뒤의 `v1/cakes/:id/`는 케이크를 CRUD 하기 위한 주소이다.

  > 도메인 네임
  > IP 주소는 '174.192.188.211' 같이 숫자로 이루어져 있다. 인터넷에 연결된 모든 컴퓨터는 다 저런 숫자들을 가지고 있다. 요청을 보내려면 저 숫자를 알아야 한다. 하지만 숫자는 불편하다. 그래서 '도메인 네임'을 사용해 사이트에 쉽게 접근할 수 있도록 한다. 도메인 네임만 치면, 우리가 알지 못하는 사이에 IP로 바뀌어서 컴퓨터의 위치를 찾는다. 즉, 도메인 네임은 IP 주소와 같다. 

<br>

<br>

------

## 🎖 Application

+ 애플리케이션은 **설치해서 사용하는 모든 프로그램**이다. 운영체제 위에 올라가는 프로그램, 설치해야 하는 프로그램, 응용 프로그램, 애플리케이션, 어플, 앱 모두 같은 그룹으로 이해하면 된다. 
+ 개발자는 1.0.0 버전의 애플리케이션을 코딩해 파일을 애플이 가지고 있는 서버 컴퓨터에 업로드한다. 사람들은 앱스토어에 접속하여 1.0.0 버전의 애플리케이션을 다운로드한다. 얼마 후, 개발자가 2.0.0으로 버전을 크게 업데이트 했고, 애플이 가지고 있는 컴퓨터에도 2.0.0 버전의 애플리케이션을 올린다. 

+ 보통 변동이 가능한 회사 정책에 관한 정보(ex) 앱의 가격)는 애플리케이션에 넣지 않는다. API로 서버에서 불러오게 만든다. 

<br>

<br>

-----

## 🎖 Web

+ HTML 문서는 운영체제에 상관없이 브라우저만 있으면 스마트폰에서도, PC에서도, 노트북에서도, 윈도우에서도, 맥에서도, IOS나 안드로이드에서도 모두 웹사이트에 접속하여 동일한 정보를 볼 수 있도록 해준다. 
+ HTML은 프로그래밍 언어가 아니다. HTML은 컴퓨터에게 특정 일을 시킬 수 있는 언어가 아닌 단지 브라우저가 볼 수 있는 문서를 적는 언어이다.

+ HTML과 CSS를 합쳐서 '퍼블리싱' 작업이라고 표현하고,  이 작업을 하는 사람들을 '퍼블리셔'라고 부른다. 
+ HTML과 CSS로는 힘든 기능들을 **Javascript**가 담당해 Web에서의 프로그래밍 언어의 역할을 한다. 

+ 네이버 검색 창에 a를 입력하면 JavaScript가 '사용자가  a를 쳤다'는 것을 감지합니다. 그리고 그 a에 해당하는 실시간 검색어 목록을 조회하는 API 요청을 네이버 서버로 보낸다. GET 요청일 것이다. 그럼 네이버 서버는 a에 대한 실시간 검색어 목록을 정리해서 응답한다. JSON 형식으로 날아올 것이다. JavaScript는 그 응답을 열어서 HTML로 바꾼다. 필요하다면 CSS도 추가할 것이다. 그리고 해당하는 부분에 끼워넣어준다. 이 모든 동작인 프로그래밍 언어인 javascript만 할 수 있다. 

+ HTML, CSS, JavaScript 완성본은 모두 서버에 있다. 아까처럼 GET 요청으로 HTML문서를 받아왔다. 서버에 있는 HTML 문서를 가져온 것이다. 그렇게 HTML을 불러온 뒤, HTML과 연결된 CSS, JavaScript, 이미지, 폰트, 동영상 등등의 파일을 다시 다운로드한다. 

  우리의 컴퓨터에 있는 HTML, CSS, JavaScript는 모두 '사본'이다. 아까 네이버 홈페이지의 html 태그를 삭제했는데, 이는 서버의 원본을 건드린 것이 아니라, 컴퓨터에 다운로드된 HTML 사본의 일부분을 지운 것으로, 새로 고침하면 다시 원본을 다운로드 받는다. 이 부분이 웹과 애플리케이션을 가르는 가장 큰 차이점이다. 

  웹은 단순히 새로고침을 통해 서버의 새로운 내용을 불러올 수 있지만, 앱은 업데이트가 필요하다.   

+ 각 브라우저는 서로 다른 애플리케이션이기 때문에 브라우저에 따라 그 안의 구현 방식이 다르다. 즉 HTML, CSS, JavaScript의 특정 기능이 버전별로, 브라우저별로 작동할 수도 있고, 작동하지 않을 수도 있다는 의미이다. 

  누구는 인터넷 익스플로러를 쓰고, 누구는 크롬을 쓰고, 누구는 사파리를 쓰는 복잡한 상황에서 웹 프론트 개발자는 소비자의 브라우저 버전과 종류에 맞춰 정상적으로 동작할 수 있도록, 추가로 코드를 작성해야 한다. 이를 **브라우저의 파편화**라고 부르고, 문제 해결을 위한 코딩을 **파편화를 잡는다**라고 표현한다. 

+ 반응형 웹 : 브라우저의 가로 넓이에 '반응'하여 구성 요소가 변하는 기술이다. 즉, 웹페이지의 크기가 사용자의 기기에 맞춰 자동으로 변형된다는 것이다. 

+ IOS 프로그램을 개발하기 위한 언어는 스위프트, Objective-C이다. 안드로이드는 자바, 코틀린이다. 이 언어들로 개발한 애플리케이션을 '네이티브 애플리케이션'이라고 한다. 원래 정해놓은 언어들을 사용해 운영체제 자체의 기능을 사용하기 때문에 '네이티브'라고 부른다.

  하지만, 운영체제 안에 브라우저가 내장되자 새로운 방식으로도 애플리케이션 개발이 가능해졌다. 바로 **애플리케이션의 특정 부분에 '브라우저'를 올리는 방식**이다. 그리고 HTML 파일을 불러올 URL을 설정해주는 것이다. 그럼 브라우저가 뜨고 그 브라우저는 HTML과 HTML에 연결된 파일들을 불러와서 보여준다. 그 부분은 HTML, CSS, JavaScript로 구성되어 있다. **네이티브와 브라우저가 혼합된 '하이브리드 애플리케이션'**이다. 

  + 애플케이션에 브라우저를 올리는 방식
    + 수정하기 좋다. 서버의 HTML, CSS, JavaScript 만 수정하면 새로 고침할 때 반영된다.  
    + 네트워크에 종속되기 때문에 와이파이나 모바일 네트워크에 가면 HTML, CSS, JavaScript 파일을 모두 다운로드하는 동안 사용자들은 기다려야한다. 
  + 네이티브로 개발하는 방식
    + 수정하기 어렵다. 심사가 복잡하고, 심사가 끝나도 사용자들이 직접 업데이트를 해줘야 한다. 
    + 잘 만든 애플리케이션은 사용성이 좋다. 네트워크를 최소한으로 이용하도록 코딩한다면 인터넷이 느린 환경에서도 빠르게 동작한다. 

<br>

<br>

-----

## 🎖 데이터베이스와 이미지 처리

#### 데이터

+ 데이터는 단 1%의 결점도 없어야 한다. 그래서 데이터를 관리하는게 어렵다.

  이를 데이터의 **무결성**이라고 한다. 따라서 데이터를 다루는 사람들은 보수적일 수 밖에 없다. 쉽게 변화를 허용하지 않는다. 

+ 현재 지배적인 데이터 베이스 방법론은 '관계형 데이터베이스' 이다. 

+ 클라이언트와 서버는 컴퓨터이기 때문에 모두 CPU, 메모리, 보조기억장치를 가지고 있다. 클라이언트와 서버 컴퓨터 위에는 모두 데이터베이스 관리 시스템을 돌릴 수 있고, 데이터를 저장할 수 있다. 따라서 데이터는 서버와 클라이언트 모두에 저장할 수 있다.

  EX) 알람 애플리케이션은 서버가 필요하지 않기 때문에 그 데이터들은 클라이언트에 있다. 

+ 어떤 데이터가 클라이언트에 있는 데이터인지 서버에서 불러온 데이터인지 헷갈린다면 **API 문서**를 보면 된다. 

<br>

#### 이미지 파일

+ 이미지 파일에는 모두 위치가 있다. 즉, '주소'가 있다. 그 이유는 **운영체제가 그 고유한 위치를 통해 이미지를 인식하기 때문**이다. 서버에서 이미지를 공유해주고, 클라이언트가 이미지의 주소를 알고 있다면, 서버에 있는 이미지를 클라이언트에서 불러올 수 있다. 클라이언트에서 서버에 있는 이미지를 불러온다는 것은 네트워크를 통해 이미지 파일을 다운 받는다는 것을 의미한다. 
+ 클라의 이미지는 빠르지만(서버에서 다운 받을 필요x) 이미지를 바꾸기 위해서는 업데이트를 해줘야 한다. 따라서 최대한 네트워크에 부담이 가지 않도록 많은 이미지를 클라이언트에 놓아야 하지만 이미지가 바뀌었을 때 서비스에 영향을 준다면, 서버에서 가져와야 한다. 
+ **관계**가 있는 이미지들은, 주소를 **DB에 넣어서 관리**한다.

<br>

<br>

## 🎖 프레임워크와 라이브러리

+ **다른 사람들이 만들어 놓은 코드를 사용할 수 있는 것**

+ 라이브러리와 프레임워크의 차이점

  프레임워크가 더 큰 개념이다. 각종 라이브러리와 코드들이 모여 프레임워크가 된다. 더불어 한 프로젝트에서 프레임워크는 하나만 쓸 수 있다.  라이브러리는 더 작은 개념으로, 망치와 가위 같은 도구들이기 때문에 한 프로젝트에서 함께 사용이 가능하다. 
