# [9095번_1, 2, 3 더하기](https://www.acmicpc.net/problem/9095)

##  Category : 브루트포스

-----

## 🎖 내 풀이

+ N과 M (1), (2)번 문제처럼 **재귀**를 이용해 풀 수 있을 것 같아서 그 문제의 재귀 코드를 참고해 짜보았지만, 재귀를 아직 완벽하게 이해하지 못한 탓일까 중간에 꼬였다. 

<br>

<br>

-------

## 🎖 Solution

### 시간 복잡도 계산 

+ 브루트 포스 문제를 해결하려면, 방법의 개수가 최대 몇개까지 나올 수 있는지 알아봐야 한다. 

  n을 1, 2, 3으로 나타내는데, 어떤 수 k1 + k2 + ... + ki = n이므로 각 k에 들어갈 수 있는 수는 1, 2, 3로 **3개**이고 k의 최대 개수는 k = 1일 때이고, n<11 이므로 최대 **10개**이다. 

  따라서 방법의 개수는 3^10 = 59049개 보다 작거나 같다고 볼 수 있다. 경우의 수가 그렇게 많지 않다. => 모든 방법의 수를 다 만들어보고 그것이 n을 넘는지 넘지 않는지 보면 된다.  

<br>

### 핵심 아이디어

+ 재귀함수의 구현

  + 무엇인가 **기준**을 정해야 됨. 어떤 기준에 따라 함수의 호출을 만들지.

    이 문제에서는 k1 + k2 + ... + ki =  n 로 식을 설정해보면, 

    k1에 어떤 수가 올지 결정하고 그 다음 k2에 어떤 수가 올지 결정하고 이 cycle을 계속 반복하다 보면 n이 나올 수도 있고, n보다 큰 값이 나올 수도 있고 n보다 작은 값이 나올 수도 있는데 일단 이 기준을 가지고 만들어보자.

  + 그러면 이 문제에서의 기준은 **위치**라고 볼 수 있다. 이 기준을 가지고 각 위치에서 **무엇을 해줄지**를 결정해줘야 하는데, 이를 **함수**에 구현해주면 된다. 

    k1에서 k2 위치로 넘어갔을 때, 즉 **기준이 바뀌었을 때 변하는 값**들을 **함수의 인자**로 넣어주면 된다.  

    이 문제에서는 **위치**가 의미하는 것이 **아직까지 사용한 수의 개수**와 같기 때문에 이를 기준으로 삼고 이를 `count`매개변수로 만들어준다. 

    그리고 기준이 바뀌었을 때 변하는 값이 무엇이 있는지 보면, k1에서 수 1를 사용할 때, 2를 사용할 때, 3을 사용할 때 **합**이 변한다. 이를 `sum` 매개변수로 만들어준다.

    그리고 입력값 `n`도 같이 넣어주자  => `go(count, sum, n)` 

  + `go(count, sum, n)` :  현재 이 함수 호출 시점에서 사용한 수의 개수는 count개 이고, 그 count개를 이용해서 합 sum을 만들었다.

  <br>

  + 이렇게 재귀함수를 구현할 때, 3가지를 고려해줘야 하는데

    1. **다음 경우 호출**

       => 어떤 하나의 함수가 다음 함수를 호출 할 때 **어떻게 호출할 수 있는지**(여기서는, 1 or 2 or 3 호출)를 모두 구해줘야 하고, 각각의 경우에 **값이 어떻게 변하는지**도 알아봐야 함.

       이 문제에서는 

       1. 1을 사용하는 경우
       2. 2를 사용하는 경우
       3. 3을 사용하는 경우가 있음.

       이 문제에서는 이렇게 **각각의 경우에 무엇을 어떻게 해야할지**(sum을 각각 다르게 넘겨준다?)가 문제에 나와있다. 

       경우에 따라서는 하나의 함수에서 다음 함수를 호출하는 방법을 스스로 찾아야 하는 경우도 있다. 이런 문제는 어렵다. 

       1. 1을 사용하는 경우 => go(count  + 1, sum + 1, n)
       2. 2를 사용하는 경우 => go(count + 1, sum + 2, n)
       3. 3을 사용하는 경우 => go(count + 1, sum + 3, n) 이렇게 호출해주면 됨

       <br>

    2. **정답을 찾은 경우**

       더이상 함수 호출을 할 필요가 없는 경우

       => sum == n 일 때

       <br>

    3. **불가능한 경우** => 함수 호출 종료 시켜줌

       1. 문제의 조건을 지키지 않는 경우
       2. 절대로 답을 구할 수 없는 경우
          + sum > n 인 경우, 더 이상 함수 호출이 의미가 없음.

    <br>

  아직까지의 내용을 바탕으로 한 재귀함수의 구현

  ```c++
  int go(int count, int sum, int goal) {
      if (sum > goal) { // 불가능한 경우
          return 0;
      }
      
      if (sum == goal) { // 정답을 찾은 경우
          return 1;
      }
      
      int now = 0;
      for (int i=1; i<=3; i++) {
          now += go(sum+i, goal);
      }
      return now;
  }
  ```



+ 이 문제는 k1의 자리에서 1로도 시작을 해봐야 되고, 2로도 시작을 해봐야 되고, 3으로도 시작을 해봐야되므로 재귀함수나에 for문을 사용해 구현을 했다. 

  ```c++
  int go(int count, int sum, int goal) {
       for (int i=1; i<=3; i++) {
          
      }
  }
  ```

  저번 문제에서도 NM과 K (1) 문제에서도 각 위치에서 시작을 해봐야 하므로 재귀함수 안에 for문을 사용해서 재귀함수를 구현했다. 

  ```c++
  ```

  









<br>

### 정답과 내 풀이 비교









































<br>

<br>

-----

## 🎖 전체 코드

### 내 코드





### 정답코드

```c++
#include <iostream>
using namespace std;

int go(int count, int sum, int goal) {
    if (sum > goal) { // 불가능한 경우
        return 0;
    }
    if (sum == goal) { // 정답을 찾은 경우
        return 1;
    }
    int now = 0;
    for (int i=1; i<=3; i++) {
        now += go(sum+i, goal);
    }
    return now;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        cout << go(0, n) << '\n';
    }
    return 0;
}
```

