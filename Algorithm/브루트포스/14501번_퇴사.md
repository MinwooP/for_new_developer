# [14501번_퇴사](https://www.acmicpc.net/problem/14501)

##  Category : 브루트포스 - 재귀

-----

## 🎖 내 풀이

+ 

<br>

<br>

-------

## 🎖 Solution

### 시간 복잡도 계산 

















<br>

### 핵심 아이디어













<br>

### 정답과 내 풀이 비교









































<br>

<br>

-----

## 🎖 전체 코드

### 내 코드

```c++
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <climits>
#include <cstring>
#include <string>
#include <vector>
#include <queue>
#include <deque>
#include <stack>
#include <map>
#include<iomanip>

using namespace std;


int T[16];
int P[16];

int ans = 0;


// go(0, N);
void go(int index, int now_p, int n) {
	 
	// 종료조건
	if (index > n) {// 더 이상 상담할 수 있는 날이 없으므로 
		if (now_p > ans)
			ans = now_p;
		return;
	}

	int temp = now_p;

	// 1. 현재 index의 상담 선택 o
	if (n - index + 1 >= T[index]) {// 현재 index의 상담에 걸리는 기간이 남은 기간보다 작을 때 이 상담 가능
		// 현재 index의 상담 선택
		temp += P[index];
		go(index + T[index], temp, n); // 상담 시 걸리는 시간 이후에 또 상담을 선택할 수 있음

		// 2. 선택했다면, 상담 선택 전으로 복구
		temp = temp - P[index];
	}

	// 3. 현재 index의 상담 선택 x
	go(index + 1, temp, n);
}


int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int N;
	cin >> N;

	for (int i = 1; i <= N; i++) {
		cin >> T[i] >> P[i];
	}

	go(1, 0, N);

	cout << ans;

	return 0;
}

```
