# 시간 복잡도와 언어별 유의사항

<br>

## 효율성

+ 프로그램이 얼마나 효율적인지 판단하는 기준
  1. 수행시간 -> 짧은 것이 중요
  2. 사용한 메모리 ->  사용하는 것이 좋음
  3. 코드의 길이 -> 짧다고 시간이 적게 걸리는 것은 X
     알아보기 쉬운 코드가 중요
+ 문제의 크기 N에 따라 걸리는 시간이 다르다 -> 시간 복잡도

<br>

## 시간 복잡도

+ 보통 N의 크기가 1억일 때, O(N) = 1초 정도?
+ 시간 제한이 1초인데, N의 크기가 100억이라면, O(N)인 방법 사용 불가, O(1)의 방법을 사용해야 함
+ Big O Notation에서 상수는 버린다. 변수가 같으면 최고차항만 남긴다
+ 두 가지 항이 있는데, 변수가 다르면 놔둔다. 

<br>

## 메모리

+ 보통 메모리 제한은 넉넉하기 때문에, 걱정할 필요가 없다. 

+ 보통 가장 많은 공간을 사용하는 것은 배열이다. 

  int형 배열 - 4byte

  ```int a[10000]```  -> 10000 x 4B = 4만 byte

  ```int a[1000000]```  -> 1000000 x 4B = 4 ,000, 000B = __3.814MB__

  ```int a[10000][10000]```  -> 381.469MB

+ 보통 메모리 사용량은 512MB 으로 제한이 주어진다. 따라서, 크게 고려하지 않아도 될 듯
+ 보통 배열의 크기가 크면 시간 초과를 받는 경우가 많다. 
+ 중복되는 값을 계속 저장하는 경우가 아니라면 웬만하면 지켜짐

<br>

## 입/출력

+ 알고리즘 문제는 

  1.  입/출력 까지 구현해야 하는 문제

  2.  함수만 구현하면 되는 문제

     가 있다. 

+ c++에서는 scanf/printf,  cin/cout을 사용할 수 있다.

+ cin/cout의 경우 아래 세줄을 추가하면 scanf/printf 만큼 빨라진다. 

  ```c++
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  cout.tie(NULL);
  ```

+ `endl;` 대신 `\n` 을 사용한다.

+ 문제의 입력이 몇 개인지 주어지지 않은 경우에는 입력을 `EOF` 까지 받으면 된다 .

  C++ : ```While (cin >> a >> b)``` 

<br>

##  시간초과

+ 의미없는 계산을 반복하고 있지는 않은지 판단

+ strlen(s)에서 s의 길이를 N이라고 한다면, strlen(s)의 값을 구하는 데  걸리는 시간이 O(N) 이다. 

  ``` c++
  for (int i=0; i<strlen(s); i++) { ~ }
  ```

  따라서 해당 반복문의 총 시간 복잡도는 O(N^2)이 된다.  따라서, s의 길이가 바뀌지 않는다면, strlen(s)의 길이를 어떤 변수에 저장해놓고 사용하는 것이 효율적.

+ ```s += "A"```에서 `+=` 연산은 추가하려는 문자열의 크기만큼 걸린다. 따라서 이 연산의 복잡도는 O(1)이고, N번 반복하므로 최종 시간 복잡도는 O(N)이다. 

  ```c++
  string s;
  int n = 1000000;
  for (int i = 0; i<n ; i++) {
      s += "A";
  }
  ```

+ ```s = s + "A";``` 에서는 매번 새로운 문자열을 만드는 것이다. 두 문자열 A, B가 있을 때 ``A+B``의 시간은 A의 크기 + B의 크기이다. 따라서, 문자열의 길이가 점점 커지므로 ```s = s + "A";``` 연산의 복잡도는 O(N)이고, 최종 시간복잡도는 O(N^2) 이다. 

  ```c++
  string s;
  int n = 1000000;
  for (int i = 0; i<n ; i++) {
      s = s +  "A";
  }
  ```
