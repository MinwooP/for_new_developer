# [3273번_두수의 합](https://www.acmicpc.net/problem/14889)

##  Category : 바킹독-배열

런타임에러, 시간초과 나서 풀이 보고 깨달음 

-----

## 🎖 내 풀이

+ 바킹독 배열 부분 강의에서 소개되었던 "어떤 수가 등장했는지를 배열에 저장하는 방법"을 이용해 풀었지만, stack에 너무 많은 메모리가 overflow되는 듯한 오류가 발생했다. 하지만 이 외에 방법은 떠오르지 않았고, 결국 정답을 보니

  int 형 배열이 아닌

  `bool occur[2000001] = { 0 };`을 선언해줌으로써, 해결할 수 있었다.

  어차피 이 배열은, 참과 거짓만을 저장하면 되기 때문에 int 형 배열로 선언해줄 필요가 없었던 것이다. 

<br>

+ 또한, 입력되는 수들의 범위가 `1 <= a <= 1000000`이고, 따라서 두 수의 합인 X의 범위가 `1 <= X <= 2000000`이기 때문에 

  a와 더해서 x가 되는 수가 이전에 등장했는지를 판단할 때, `if(occur[X-v[i]] == 1)`를 검사할 텐데, 예를 들어, `X`가 2000000이고 `v[i]`가 100 인 상황처럼, `occur[ ]` 배열의 index가 1000000보다 큰 index에 접근해야할 상황이 있을 수 있으므로, 가장 큰 index가 접근해야 될 상황이 `X`가 2000000이고, `v[i]`가 1인 경우이기 때문에  `occur[ ]` 배열의 크기를 최소 2000000로 설정해야 한다. 

  ```c++
  if (X - v[i] > 0 && occur[X - v[i]] == 1) {
  			cnt++;
  		}
  ```

<br>

+ 그리고 `if(occur[X-v[i]] == 1)`를 검사할 때, `X`가 500이고, `v[i]`가 1000인 경우처럼, `X`보다 `v[i]`가 큰 경우도 있으니 `if(X-v[i] > 0)`의 조건도 검사를 해줘야 한다. 

<br>

<br>

-------

## 🎖 Solution

### 시간 복잡도 계산 

<br>

### 핵심 아이디어

+ 특정 수가 이전에 나왔었는지를 저장하는 배열 `bool occur[ ]`을 사용하는 것.

+ 입력받는 수들의 범위로 인해, 접근되는 배열의 인덱스 크기 고려하기

<br>

### 정답과 내 풀이 비교

<br>

<br>

-----

## 🎖 전체 코드

### My code

```c++

```

<br>

<br>

### 정답 보고 내 코드 수정

```c++
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <climits>
#include <cstring>
#include <string>
#include <vector>
#include <queue>
#include <deque>
#include <stack>
#include <map>
#include<iomanip>

using namespace std;

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int N, X;
	vector<int> v;

	cin >> N;
	int num;
	for (int i = 0; i < N; i++) {
		cin >> num;
		v.push_back(num);
	}
	cin >> X;

	bool occur[2000000] = { 0 };
	int cnt = 0;

	for (int i = 0; i < N; i++) {
		if (X - v[i] > 0 && occur[X - v[i]] == 1) {
			cnt++;
		}
		occur[v[i]] = 1;
	}

	cout << cnt;

	return 0;
}
```

<br>

<br>

### Solution code

```c++

```

