## 배열

------

### 🚩정의와 성질

배열

=> 메모리 상에 원소를 연속적으로 배치한 자료구조

원래 C++ 에서는 예를 들어 `int arr[10];`으로 배열을 선언한 뒤에는 arr의 길이를 변경하는 게 불가능하지만, 자료구조로써의 배열에서는 길이를 마음대로 늘리거나 줄일 수 있다고 생각해보자.

<br>

배열의 성질

+ O(1)에 k번째 원소를 확인/변경가능

  => 배열은 각 원소들이 메모리 상에 연속적으로 배치되어 있기 때문에 k번재 원소를 확인하려면 시작주소에서 k칸 만큼 오른쪽을 가면 되니까 바로 계산 가능

+ 추가적으로 소모되는 메모리의 양(overhead)가 거의 없음

  => 다른 자료구조들과 비교했을 때, 이게 무슨 말인지 알 수 있을 것

+ Cache hit rate가 높다 

  => 메모리 상에 데이터들이 붙어있기 때문

  > Cache hit rate

+ 미모리 상에 연속한 구간을 잡아야해서 할당에 제약이 걸림 

<br><br>

------

### 🚩기능과 구현

배열에서 제공되는 연산들 

1. 임의의 위치에 있는 원소를 확인, 변경하는 것은 O(1)이지만, 임의의 위치에 원소를 추가하거나 제거하는 것은 O(N)이다. 

   => 추가할 시,  그 뒤 원소들을 뒤로 한칸씩 미뤄야 하기 때문에

<br>

임의의 위치에 원소를 추가, 제거하는 코드 짜보기

```c++
void insert(int idx, int num, int arr[], int& len) {
	for (int i = len; i > idx; i--) {
		arr[i] = arr[i-1];
	}

	arr[idx] = num;
	len++;
}

void erase(int idx, int arr[], int& len) {  
	for (int i = idx; i < len-1; i++) {
		arr[i] = arr[i+1];
	}

	len--;
}
```

<br>

##### 배열 사용 팁 

fill함수를 이용해 배열 초기화 => 실수할 여지가 없고 코드도 짧으니 추천

`fill(초기화 시키고 싶은 부분의 시작주소, 초기화시키고 싶은 부분의 끝 주소, 초기화할 값)`

```c++
int a[21];
fill(a, a+21,0);

int b[21][21];
for(int i=0;i<21;i++){
    fill(b[i], b[i]+21, 0);
}
```

벡터라면,

`fill(v.begin(), v.end(), 0)` 

이렇게 초기화해주면 된다. 

<br>

배열 초기화 방법

1. 배열 arr의 원소를 모두 0으로 초기화하고 싶다면

   `int arr[5] = {};`

2. 배열의 0번째 원소만 10으로 초기화하고, 나머지는 다 0으로 초기화하고 싶다면

   `int arr[5] = {10};` or `int arr[5] = {10,};`

> `int freq[26];`
> 이 코드를 전역에 선언하면, 0으로 초기화되지만
> 지역에 선언하면 쓰레기 값으로 초기화되기 때문에 
>
> `int freq[26]=  {0};`등의 방법으로 초기화해줘야 함.

<br><br>

------

### 🚩STL Vector

vector는 배열과 거의 동일한 기능을 수행하는 자료구조로, 배열과 마찬가지로 원소가 메모리에 연속하게 저장되어 있음

O(1)에 인덱스를 가지고 각 원소로 접근가능

하지만 vector는 배열과 달리 크기를 자유자재로 늘이거나 줄일 수 있음

나중에 그래프의 인접 리스트를 저장할 때에는 vector를 쓰는게 많이 편해서 vector가 필요하게 되지만 그전까지는 사실 굳이 배열 대신 vector를 써야하는 상황이 딱히는 없음. 

<br>

##### vector 사용 연습

```c++
#include <bits/stdc++.h>
using namespace std;

int main(void) {
	vector<int> v1(3, 5); // {5,5,5};
	cout << v1.size() << '\n'; // 3
	v1.push_back(7); // {5,5,5,7};

	vector<int> v2(2); // {0,0};
	v2.insert(v2.begin() + 1, 3); // {0,3,0};

	vector<int> v3 = { 1,2,3,4 }; // {1,2,3,4}
	v3.erase(v3.begin() + 2); // {1,2,4};

	vector<int> v4; // {}
	v4 = v3; // {1,2,4}
	cout << v4[0] << v4[1] << v4[2] << '\n';
	v4.pop_back(); // {1,2}
	v4.clear(); // {}
}
```

 <br>

##### vector loop

1. range-based for loop => C++11 부터 추가된 기능

```c++
for(int e: v1)
    cout << e << ' ';
```

 <br>

2. for loop

```c++
for(int i=0; i<v.size(); i++)
    cout << v[i] << ' ';
```

 <br> <br>

------

### 🚩연습문제

강의 중 연습문제)

주어진 길의 N의 int 배열 arr에서 합이 100인 서로 다른 위치의 두 원소가 존재하면 1을, 존재하지 않으면 0을 반환하는 함수 fun2(int arr[], int N)을 작성하라. arr의 각 수는 0이상 100 이하이고, N은 1000 이하이다. 

> 특별히, O(N)의 시간복잡도를 가지는 

fun2({1, 52, 48}, 3) = 1,

fun2({50, 42}, 2) = 0.

 <br>

내 풀이)

이 문제는 제일 쉽게 생각하면, 그냥 1번째 원소와 2, 3 ... 마지막 원소까지 더해보고, 2번째 원소와 3, 4 ... 마지막 원소까지 더 해보고 이렇게 각 원소끼리 모두 더해보면 정답을 구할 수도 있다. 하지만 이는 `O(n^2)`의 시간 복잡도를 가진다.

 <br>

Solution)

하지만 O(n)의 시간 복잡도의 풀이도 있다.

```c++
int func2(int arr[], int N){
    int occur[101] = {};
    for(int i=0;i<N;i++){
        if(occur[100-arr[i]] == 1){
           return 1;
        }
        occur[arr[i]] = 1;
    }
    return 0;
}
```

이전에는 앞에서부터 모든 쌍을 살펴보면서 합이 100이 되는 쌍의 존재 여부를 확인했지만 

이번에는 수를 차례로 하나씩 읽으면서 이전에 등장한 수 중에서 지금 보고 있는 수와 더해 100이 되는 수가 있는지를 알고 싶다.

예를 들어, 현재 60이라는 수를 보고 있다면, 이전에 등장한 수 중에 60과 더해 100이 되는 수가 있는지를 알고 싶은 것.

=> 이는 60과 더해 100이 되는 수는 40이니, 이전에 40이 등장했는지를 확인하면되는 것 

=> 60 이전에 1, 23, 53, 77의 수가 있다면, {1, 23, 53, 77}에서 40이 있는지를 확인해야 하는데, 이 과정에서 1, 23, 53, 77 각각을 하나하나 다 40과 비교해 같은지 확인한다고 치면  O(N)이 걸리고, 이 과정을 N번에 걸쳐 진행하니  총 시간 복잡도는 그대로 O(N^2)이므로 우리가 원하는 방법이 아니다.

=> 따라서 다른 방법이 필요하다. 

=>1, 23, 55, 77은 이전에 모두 검사했던 수인데 지금 60에 대해서 검사할 때도 다시 검사한다며, 한번씩 더 검사하게 되는 것. 이러한 중복을 줄이기위해 이전에 검사했던 수들을 어디에 저장해두는 방법이 있으면 좋을 것 같다.

=> 각 수가 이전에 등장했는지를 체크하는 배열을 만들어 이를 관리할 수 있다. 	

=> `int occurr[101]`의 배열을 만들고, 각 index에 해당하는 숫자가 이전에 등장한 적이 없으면 0, 등장한 적이 있으면 1의 값을 그 index의 위치에 저장해주면 된다. 

=> 이 코드는 나와 합이 100이 되는 원소를 매 순간마다 O(1)에 찾고 이 행위를 N번 반복하기 때문에 총 시간 복잡도는 O(N)이 된다. 

 <br>

##### 이상적인 사고의 과정

O(N)의 시간복잡도로 문제를 해결해야 하니 배열의 원소를 한번씩 지나가면서, 그 때 각 작업을 다 끝내야 한다. 또 배열을 탐색하거나 그러면 O(N)보다 넘어가기 때문에 

=> 각 배열의 원소를 차례로 지나가면서, 무엇을 해야할까. 예를 들어 {1, 23, 55, 77} 의 배열이 있다면 23의 차례라면, 23과 합해서 100이 되는 원소가 