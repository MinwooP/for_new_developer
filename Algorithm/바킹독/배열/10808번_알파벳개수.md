# [10808번_알파벳개수](https://www.acmicpc.net/problem/10808)

##  Category : 바킹독-배열

-----

## 🎖 내 풀이

```c++
int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int numOfChar[123] = { 0 };
	string s;

	cin >> s;

	for (int i = 0; i < s.size(); i++) {
		numOfChar[s[i]]++;
	}

	for (int i = 97; i < 123; i++) {
		cout << numOfChar[i] << ' ';
	}
	return 0;
}
```

모든 원소의 값이 0인 배열을 만들고, 각 알파벳의 아스키코드값과 같은 값의 인덱스를 가지는 각 배열의 원소가 각 알파벳의 개수를 담도록 했다.

예를 들어, `a`의 아스키코드값은 97이니까, `numOfChar[97]`은 단어 중 `a`의 개수를 담도록 했다.

그래서 문자열 `s`의 char 하나하나씩 for문으로 돌면서 `numOfChar[s[i]]++;`를 통해 각 알파벳이 나올때마다 각 알파벳에 해당하는 배열 원소의 값을 증가시켜줬다.  

<br>

<br>

-------

## 🎖 Solution

### 시간 복잡도 계산 

<br>

### 핵심 아이디어

각 알파벳은 정수이고, 이 값은 아스키코드표에 나와있음.

<br>

### 정답과 내 풀이 비교

##### 정답코드

```c++
// Authored by : BaaaaaaaaaaarkingDog
// Co-authored by : -
// http://boj.kr/d7178d89538a42ababf4455443e60fe2
#include <bits/stdc++.h>
using namespace std;

int freq[26];
int main(void) {
  ios::sync_with_stdio(0);
  cin.tie(0);
  string s;
  cin >> s;
  for(auto c : s)
    freq[c-'a']++;
  for(int i = 0; i < 26; i++)
    cout << freq[i] << ' ';
}
```

내 풀이와 비슷한 것 같지만, 여기서는 알파벳이 총 26개이므로, `freq` 배열의 `freq[0]`가 `a`의 개수를 담고, `freq[25]`가 `z`의 개수를 담도록 했다. 

이를 위해서, `freq[c-'a']`처럼, 각 알파벳에서 `a`의 값을 빼줌으로써, 각 알파벳을 인덱스 0부터 26으로 표현할 수 있도록 만들었다. 

```c++
for(auto c : s)
    freq[c-'a']++;
```

나의 방법보다 더 보기 좋고, 깔끔한 방법인 것 같다.


