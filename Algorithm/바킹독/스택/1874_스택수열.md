# [1874번_ 스택수열](https://www.acmicpc.net/problem/1874)

##  Category : 바킹독-스택

-----

## 🎖 내 풀이

+ 임의의 수열이 주어졌을 때 스택을 이용해 그 수열을 만들 수 있는지 없는지를 판단하는 기준이 무엇일까, 고민했고 예제 입력들을 따라가며 직접 해본 결과, pop을 통해 얻어야 하는 숫자보다 수열의 맨 앞이 항상 작거나(계속 push) 같아야(이 때 pop) 한다는 것을 알게되었다.

  예를 들어, 현재 수열 `4,3,6,8, ... 1`의 맨 앞이 4이고, 현재 스택에는 아무요소도 없을 때, 1,2,3,4를 차례대로 push 할 것이고, 이후 4를 pop 하게 될 것이다. 여기서 1,2,3,4 모두 4보다 작거나 같은 수이고, 이후에는 3을 pop할 것이다. 그리고 다음 수열의 맨 앞수는 6이기 때문에, 5,6을 push할 것이고, 5,6은 여전히 6보다 작거나 같은 수이다. 계속 이런식으로 반복된다면 스택을 이용해 수열을 만들 수 있지만, 

  `1,2,5,3,4`의 수열을 예로 들면, 5까지 pop 했다고 생각했을 때, 현재 스택에는 1,2,3,4 가 들어가있고, 남은 수열의 수는 3,4인데 여기서 수열의 맨 앞 수인 3보다 큰 4가 현재 스택에서 pop을 통해 얻어야할 숫자이므로, 이 상황은 불가능한 상황임을 알 수 있다.

+ 나는 push하면서 만들어갈 스택 `s`, 수열을 담고 있는 list `L`, 마지막에 출력할 정답을 담고있는 vector `ans` 변수, 이렇게 총 3개의 변수를 선언했지만 solution 코드를 보니 push 하면서 만들어갈 스택만 정의하였다. 

  각 한줄마다 수열의 수가 입력되므로, 굳이 수열의 각 수를 저장할 필요 없이, 수열의 각 수가 입력될 때마다 이에 따른 스택 연산을 해주면 되기 때문에, 따로 수열을 담고 있는 변수를 선언해주지 않았다.

  또한, 정답을 담을 변수를 vector로 선언하지 않고, string 변수로 선언하고, ` ans += "+\n";`의 방식을 통해서 이 string 변수에 정답을 계속해서 담고, 나중에 이 변수를 출력한다면 나처럼 vector를 순회하면서 출력할 필요도 없어진다.

<br>

<br>

-------

## 🎖 Solution

### 시간 복잡도 계산 

<br>

### 핵심 아이디어

+ pop을 통해 얻어야 하는 숫자보다 top이 항상 작거나(계속 push) 같아야(이 때 pop) 한다. 

<br>

### 새롭게 알게 된 점



<br>

<br>

-----

## 🎖 전체 코드

### My code

```c++
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <climits>
#include <cstring>
#include <string>
#include <vector>
#include <queue>
#include <deque>
#include <stack>
#include <map>
#include<iomanip>
#include<list>

using namespace std;

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	stack<int> S;
	list<int> L;
	vector<char> ans;
	int N;

	cin >> N;
	int num;
	for (int i = 0; i < N; i++) {
		cin >> num;
		L.push_back(num);
	}

	int idx = 1;

	while (!L.empty()) {
		if (S.empty()) {
			S.push(idx++);
			ans.push_back('+');
		}
		else {
			if (S.top() > L.front()) {
				cout << "NO";
				return 0;
			}

			while (S.top() < L.front()) {
				S.push(idx++);
				ans.push_back('+');
			}

			if (S.top() == L.front()) {
				S.pop();
				L.pop_front();
				ans.push_back('-');
			}
		}
	}

	for (int i = 0; i < ans.size(); i++) {
		cout << ans[i] << '\n';
	}

	return 0;
}
```

<br>

<br>

### After code refactoring

```c++
```

<br>

<br>

### Solution code

```c++
#include <bits/stdc++.h>
using namespace std;

int main(void) {
  ios::sync_with_stdio(0);
  cin.tie(0);
  int n;
  cin >> n;
  stack<int> S;
  int cnt = 1;
  string ans;
  while (n--) {
    int t;
    cin >> t;
    while (cnt <= t) {
      S.push(cnt++);
      ans += "+\n";
    }
    if (S.top() != t) { 
      cout << "NO\n";
      return 0;
    }
    S.pop();
    ans += "-\n";
  }
  cout << ans;
}

```

