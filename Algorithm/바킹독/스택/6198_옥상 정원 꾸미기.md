# [6198번_옥상 정원 꾸미기](https://www.acmicpc.net/problem/6198)

##  Category : 바킹독-스택

## 🎖 내 풀이

같은 스택 카테고리에 있는 `2493번_탑` 문제를 풀었던 방식과 비슷하게 풀면 될 것 같다고 생각했다.

핵심 아이디어는

각 height을 입력받을 때마다, 현재까지 쌓여진 스택에서 그 height의 건물을 바라볼 수 있는 건물들(입력받은 height보다 큰 값을 가지는 건물들) 만 놔두고, 그 건물을 바라볼 수 없는 건물들(입력받은 height보다 작은 값을 가지는 건물들)은 pop 한다.(현재 건물을 바라볼 수 없다면, 그 오른쪽의 건물들도 바라볼 수 없을 것이므로 pop해버려도 됨. 그러면 stack에는 그 height의 건물을 바라볼 수 있는 건물들만 남아있을 것이므로 이때의 stack의 size를 ans에 더해주고, height을 stack에 push한다. 

이다. 

<br><br>

## 🎖정답과 내 풀이 비교

틀렸습니다 라고 나오길래, 정답을 봤더니 

입력받는 각 건물의 높이에 해당하는 변수 `height`과 정답을 담는 변수 `ans`를 `int`가 아닌, `long long`으로 선언해줬어야했다.

=> N이 80,000이고 빌딩의 높이들이 동일하지 않은 상태에서 내림차순으로 주어진다면 정답이 int 형의 범위를 벗어나기 때문입니다.

=> n=80000이고 자기 위치 다음 빌딩들이 모두 자기보다 작다하면 80000+ 79999 + 79998 +... 이런 예시가 들어온다. 대략 n^2으로 계산하면 6.4*10^9 으로 int 범위가 넘어가므로 ans는 long long 형으로 해준다.



그래서, `height`과 `ans`의 자료형만 바꿔줬더니 맞았다. 

height의 범위는 `1 ≤ hi ≤ 1,000,000,000` 이므로 `int`형으로만 선언해줘도 된다. 

<br><br>

## 🎖 핵심 아이디어



<br><br>

-----

## 🎖 전체 코드

### My code

```c++
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <climits>
#include <cstring>
#include <string>
#include <vector>
#include <queue>
#include <deque>
#include <stack>
#include <map>
#include<iomanip>
#include<list>

using namespace std;

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int N;
	cin >> N;

	long long ans = 0;
	stack<int> S;

	long long height;
	while (N--) {
		cin >> height;
		
		while (!S.empty() && S.tp() <= height) {
			S.pop();
		}

		ans += S.size();

		S.push(height);
	}
	cout << ans;

	return 0;
}
```

<br>

<br>

### Solution code

```c++

```
