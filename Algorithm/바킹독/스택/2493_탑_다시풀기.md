# [2493번_탑](https://www.acmicpc.net/problem/2493)

##  Category : 바킹독-탑

-----

## 🎖 내 풀이

내 풀이 대로 풀면 계속 시간초과가나서 솔루션 코드보고 이해해고 다시 안보고 짜봤음 => 나중에 다시 풀어보기 

+ 결국 주어지는 각 N개의 수마다 "**현재 수의 왼쪽에 있는 수들 중 현재 수보다 큰 수들 중 가장 가까이 있는 수의 index**"를 구하는 문제라고 생각해서, 내가 이 문제를 풀 때 가장 집중했던 건, 어떻게 하면 n^2이 아닌, n의 시간복잡도로, 즉, stack에 푸쉬하면서 또는 각 수를 입력받으면서 한번에 이를 구할 수 있을까 였다. 

+ 왜냐하면, 배열을 이용해 구현했을 때도, n^2의 시간복잡도로는 구현했는데 시간초과가 났기 때문이다. 예를 들어, `6 9 5 7 4`의 수가 입력된다고 하면, int형 배열 `ans[0]` ~ `ans[4]`를 처음에 모두 0으로 초기화해놓고,  6부터 시작해서 9는 6보다 크으므로 9의 신호를 받지 못할 것이고, 5는 6보다 작으므로 5의 신호를 받을 수 있기 때문에 `ans[2]`의 값을 6의 자릿수 1로 변경하고, 7>6이므로 6은 7의 신호를 받을 수 없기 때문에 pass, 6는 4의 신호를 받을 수 있으므로 `ans[4]`의 값도 1로 변경한다. 

+ 이러한 과정을 9, 5, 7도 반복해서 결국 각 `ans[i]`가 "해당 수에서 신호를 보내면 받을 수 있는 수들 중 가장 큰 수"가 되도록 업데이트 하는 풀이로 코드를 짰다. 하지만 이 방식은 `n^2`의 시간복잡도를 가질 것이므로 시간 초과가 났다.

  ```c++
  // V : 6 9 5 7 4
  // 원래 ans : 0 0 0 0 0 
  
  for (int i = 0; i < N - 1; i++) { // 0, 1, 2, 3, 4 i
  	for (int j = i; j < N; j++) { 
  		if (V[i] > V[j] && ans[j] < i) {
  			ans[j] = i+1;
  		}
  	}
  }
  ```

<br><br>

### 🎖정답과 내 풀이 비교

+ 그리고 정답을 보니, 맨 처음 내가 stack을 이용해서 짰던 방식과 비슷한 구현이었다. 핵심 아이디어는 **"현재의 높이보다 더 큰 높이(신호가 도달할 수 있는 높이)가 나올때까지 스택을 pop 한다"** 였다. 

  ```c++
  while (S.top().first < height)
  	S.pop();
  ```

+ 하지만 solution과 내 풀이의 다른 점은,

  내 풀이는 우선, 주어진 수들을 다 stack에 push한 후, 맨 뒤의 수부터 pop 하면서 차례대로 검사하는 방식이었고, 즉, 

  <---------

  <-------

  <-----

  <--

  solution 코드는 주어진 수들을 하나하나 push 하고, 검사하는 방식이었다. 즉,

  <--

  <-----

  <-------

  <---------

  이런 방식이었다. 

  하지만 solution code는 `pair`를 사용함으로써, stack을 하나만 사용했고(나는 3개를 사용), **오른쪽에 더 큰 수가 나온다면 왼쪽의 작은 수들을 pop해줘서**, 계속 그 수들을 고려하지 않아도 되도록 만들어줌으로써 시간 복잡도를 줄였다.

<br><br>

## 🎖 핵심 아이디어

+ 현재의 높이보다 더 큰 높이(신호가 도달할 수 있는 높이)가 나올때까지 스택을 pop 한다

+ 오른쪽에 더 큰 수가 나온다면 왼쪽의 작은 수들을 pop해줘서 속 그 수들을 고려하지 않아도 되도록 만들어줌으로써 시간 복잡도를 줄이기
+ 각 수의 자릿수와 높이를 pair에 한꺼번에 저장함으로써, 자릿수에 대한 변수나 자료구조를 사용하지 않아도 되도록 

<br><br>

-----

## 🎖 전체 코드

### My code

```c++
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <climits>
#include <cstring>
#include <string>
#include <vector>
#include <queue>
#include <deque>
#include <stack>
#include <map>
#include<iomanip>
#include<list>

using namespace std;

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	vector<int> V;
	vector<int> ans;
	int N;
	cin >> N;
	
	int num;
	for (int i = 0; i < N; i++) { 
		cin >> num;
		V.push_back(num);
		ans.push_back(0);
	}
	
	for (int i = 0; i < N - 1; i++) { // 0, 1, 2, 3, 4 i
		for (int j = i; j < N; j++) { 
			if (V[i] > V[j] && ans[j] < i) {
				ans[j] = i+1;
			}
		}
	}

	for (int i = 0; i < V.size(); i++) {
		cout << ans[i] << " ";
	}


	return 0;
}
```

<br>

<br>

### Solution code

```c++
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <climits>
#include <cstring>
#include <string>
#include <vector>
#include <queue>
#include <deque>
#include <stack>
#include <map>
#include<iomanip>
#include<list>

using namespace std;

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	stack<pair<int, int>> S;

	int N;
	cin >> N;

	S.push(make_pair(100000001, 0));

	for (int i = 1; i <= N; i++) {

		int height;
		cin >> height;

		while (S.top().first < height)
			S.pop();

		cout << S.top().second << " ";

		S.push(make_pair(height, i));
	}
	return 0;
}
```
