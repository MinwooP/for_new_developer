# 연결리스트

## 🚩정의와 성질

연결리스트

=> 원소들을 저장할 때, 그 다음 원소가 있는 위치를 포함시키는 방식으로 저장하는 자료구조.

<br>

연결리스트의 성질

+ k번째 원소를 확인/변경하기 위해 O(k)가 필요함

  3 -> 13 -> 72 -> 5 인 list가 있을 때, 72를 찾고 싶으면 3을 거쳐서 13을 가고, 13을 거쳐서 72에 접근해야하기 때문

  배열과 달리 공간에 원소들이 연속해서 위치하고 있지 않기 때문에 직접 따라가면서 확인해야한다. 

+ 임의의 위치에 원소를 추가 / 임의 위치의 원소 제거는 O(1)

  => 배열과 비교했을 때, 큰 차이가 있는 성질  

+ 원소들이 메모리 상에 연속해있지 않아 Cache hit rate가 낮지만, 할당이 다소 쉬움

<br>

연결리스트의 종류

![image-20230317043218138](C:\Users\alsd2\AppData\Roaming\Typora\typora-user-images\image-20230317043218138.png)

<br>

배열 vs 연결리스트

배열과 연결리스트는 메모리 상에 원소를 놓는 방법은 다르다고 해도 어찌됐든 원소들 사이의 선후 관계가 일대일로 정의가 된다. 즉, 원소들 사이에서 첫번째 원소, 두번째 원소 ... 이런 개념이 존재하는 것 !

=> 배열과 자료구조는 선형 자료구조

![image-20230317043445591](C:\Users\alsd2\AppData\Roaming\Typora\typora-user-images\image-20230317043445591.png)

연결리스트에서 추가적으로 필요한 공간(Overhead) => O(N)

=> 배열은 데이터만 딱딱 저장하면 될 뿐 딱히 추가적으로 필요한 공간이 없다. (굳이 따지면 길이 정보를 저장할 int 자료형 1개?)

=> 연결리스트에서는 각 원소가 다음 원소, 혹은 이전과 다음 원소의 주소값을 가지고 있어야 하므로 32비트 컴퓨터면 주소값이 32비트 (4바이트) 단위이니 4N 바이트가 추가로 필요하고, 64비트 컴퓨터라면 8N 바이트가 추가로 필요하게 된다. 즉, N에 비례하는 만큼의 메모리를 추가로 쓰게 된다,

<br><br>

-----

## 🚩기능과 구현

+ 임의의 위치에 있는 원소를 확인/변경하는 연산 => O(N) 

  임의의 위치에 있는 원소로 가기 위해서는 그 위치에 도달할 때까지 첫번째 원소부터 순차적으로 방문해야 한다. 분명 모든 원소들은 메모리 어딘가에 있을테지만, 그 중에서 우리는 첫 번째 원소의 주소만 알고 있다. 

  전체 N개의 원소가 있다고 생각하면, 평균적으로 N/2의 시간이 걸릴테니 O(N)이라고 생각하면 된다 .

<br>

+ 임의의 위치에 원소를 추가 => O(1) (추가하고 싶은 위치의 주소를 알고 있을 경우)

  ![image-20230317173525122](C:\Users\alsd2\AppData\Roaming\Typora\typora-user-images\image-20230317173525122.png)

  배열처럼 그 뒤의 원소들을 전부 옮기는 작업을  할 필요가 없고 그냥 21과 84에서 다음 원소의 주소만 변경을 해주면 된다. 

<br>

+ 임의의 위치의 원소를 제거 => O(1)

  위의 그림에서 21을 제거하고 싶다면, 65의 다음 원소가 21이 아닌 84임을 알려주면 된다. 즉, 65의 다음 원소의 주소를 84의 주소로 쓰면 된다.  

<br>

=> **임의의 위치에서 원소를 추가하거나 제거하는 연산을 많이 해야 할 경우**에는 연결리스트의 사용을 고려해보면 좋다. 

<br>

### 구현

```C++
struct NODE {
    struct NODE *prev, *next;
    int data;
}
```

이를 기반으로 한 구현 방법은 알고 있어야 하지만, 실제 코딩 테스트에서는 그냥 STL list를 활용하면 됨.

- [ ] 링크드 리스트 구현해보기 

<br><br>

--------

## 🚩STL List

코딩테스트에서 STL을 허용하지 않는다면(이런 경우는 드물다) 직접 연결 리스트를 구현해야 한다. 

=> 정석적인 구현이 아닌 야매 구현으로 하면 구현 난이도가 어렵지 않다.

<br>

### 야매 연결 리스트

```c++
const int MX = 1000005;
int dat[MX], pre[MX], nxt[MX];
int unused = 1;

fill(pre, pre+MX, -1);
fill(nxt, nxt+MX, -1);
```

원소를 배열로 관리하고, pre와 nxt에 이전/다음 원소의 포인터 대신 배열 상의 인덱스를 저장하는 방식으로 구현한 연결리스트이다. 메모리 누수의 문제 때문에 실무에서는 절대 쓸 수 없는 방식이지만 코딩테스트에서는 구현 난이도가 일반적인 연결리스트보다 낮고 시간 복잡도도 동일하기 때문에 애용하면 된다. 

구현에 필요한 변수들

dat[i] : i번째 원소의 값

pre[i] : i번지 원소에 대해 이전 원소의 인덱스

nxt[i]: i번지 원소에 대해 다음 원소의 인덱스 

pre나 nxt의 값이 -1이면 해당 원소의 이전/다음 원소가 존재하지 않는다는 의미

unused는 현재 사용되지 않는 인덱스, 즉 새로운 원소가 들어갈 수 있는 인덱스이다. 원소가 추가된 이후에는 1씩 증가될 것이다. 

특별히 0번지는 연결리스트의 시작 원소로 고정되어 있다. 즉, 0번지는 값이 들어가지 않고 단지 시작점을 나타내기 위한 dummy node이다. 

![image-20230317180647432](C:\Users\alsd2\AppData\Roaming\Typora\typora-user-images\image-20230317180647432.png)

<br>

#### 연결리스트의 각 함수 구현

##### traverse 함수

연결 리스트의 모든 원소들을 출력 

```c++
void traverse(){
    int cur = nxt[0];
    while(cur != -1){
        cout <<  dat[cur] <<' ';
        cur = nxt[cur];
    }
    cout << "\n\n";
}
```

<br>

##### insert 함수

```c++
void insert(int addr, int num){
    data[unused] = num;
    pre[unused] = addr;
    nxt[unused] = nxt[addr];
    if(nxt[addr] != -1)
        pre[nxt[addr]] = unused;
    nxt[addr] = unused;
    unused++;
}
```

`if(nxt[addr] != -1)`

=> 맨 마지막 원소의 뒤에 새 원소를 추가하는 상황이라면, 삽입할 위치의 다음 원소가 존재하지 않기 때문에 그런데도 pre[nxt[addr]] = unused;라고 써버리면 pre[-1]에 접근할 수도 있기 때문에 

<br>

##### erase 함수

1. 이전 위치의 nxt를 삭제할 위치의 nxt로 변경
2. 다음 위치의 pre를 삭제할 위치의 pre로 변경 

```c++
void erase(int addr){
    nxt[pre[addr]] = nxt[addr];
    if(nxt[addr] != -1)
        pre[nxt[addr]] = pre[addr];
}
```

<br><br>

### STL list

```c++
int main(void) {
    list<int> L = {1, 2}; // 1 2 
    list<int>::iterator t = L.begin(); // t는 1을 가리키는 중
    L.push_front(10); // 10 1 2 
    cout << *t << '\n'; // t가 가리키는 값 = 1을 출력
   	L.push_hack(5); // 10 1 2 5
    L.insert(t, 6); // t가 가리키는 곳 앞에 6을 삽입, 10 6 1 2 5 
    t++; // t를 1칸 앞으로 전진, 현재 t가 가리키는 값은 2
    t = L.erase(t); // t가 가리키는 값을 제거, 그 다음 원소인 5의 위치를 반환
    				// 10 6 1 5, t가 가리키는 값은 5
    cout << *t << '\n'; // 5
    for(auot i: L) cout << i << ' ';
    cout << '\n';
    for(list<int>::iterator it = L.begin(); it != L.end();it++)
        cout << *it << ' ';
} 	
```

+ double linked list의 구조를 가지고 있음 
+ push_back, pop_back, push_front, pop_front 는 모두 O(1)

+ 여기서는 iterator가 주소 역할을 한다. 

  3번째 줄에서 `list<int>::iterator`라는 type을 C++11 이상일 때 `auto t = L.begin()`으로 써도 된다. 

<br>

### List 기본 함수

iterator(반복자)

- begin() : beginning iterator를 반환
- end() : end iterator를 반환

<br>

추가 및 삭제

- push_front(element) : 리스트 제일 앞에 원소 추가

- pop_front() : 리스트 제일 앞에 원소 삭제

- push_back(element) : 리스트 제일 뒤에 원소 추가

- pop_back() : 리스트 제일 뒤에 원소 삭제

- insert(iterator, element) : iterator가 가리키는 부분 “**앞**”에 원소를 추가

  > iterator에는 insert 후에도 기존에 가리키던 원소를 가리키고 있음
  >
  > ex) `1 2 3 4 (t) 5 6 ` 라면
  > `L.insert(t, 10);`
  >
  > => `1 2 3 4 10 (t) 5 6`

- erase(iterator) : iterator가 가리키는 부분에 원소를 삭제

  > iterator가 가리키는 부분의 원소를 삭제하고, 그 후에는 그 오른쪽의 원소를 가리키게 된다. 
  >
  > erase는 항상 `L.erase(t);` 이렇게 단독으로 쓰이는 게 아니라 `t = L.erase(t);` 이렇게 쓰인다. 
  >
  > `L.erase(t);` 이렇게 단독으로만 쓰면, iterator t는 삭제된 element의 주소값을 가리키고 있을 것이기 때문에 에러가 발생할 수 있다. 
  >
  >  `L.erase(t);` 는 삭제된 원소의 다음 element의 주소값을 return 하기 때문에, iterator를 그 값으로 변경해주기 위해 `t = L.erase(t);` 이런식으로 사용한다.
  >
  > 참고
  >
  > + https://codingdog.tistory.com/entry/c-list-erase-%ED%95%A8%EC%88%98-%EC%82%AC%EC%9A%A9%EB%B2%95%EC%9D%84-%EA%B0%84%EB%8B%A8%ED%95%98%EA%B2%8C-%EC%95%8C%EC%95%84%EB%B4%85%EC%8B%9C%EB%8B%A4

<br>

조회

- *iterator : iterator가 가리키는 원소에 접근
- front() : 첫번째 원소를 반환
- back() : 마지막 원소를 반환

<br>

기타

- empty() : 리스트가 비어있으면 true 아니면 false를 반환
- size() : 리스트 원소들의 수를 반환

<br><br>

##  연습문제

연결 리스트 문제는 대부분 지금 문제처럼 ***원소들을 돌아다니면서 이동하다가 삭제나 삽입이 필요***한 문제들이다. 

그런데 만약 N이 5000 정도로 작다면 그냥 O(n^2)으로 짜도 통과되니 익숙한 vector로 구현을 해도 된다. 하지만 N이 굉장히 클 때는 연결리스트를 이용해 구현을 해야 한다.

<br>

https://www.acmicpc.net/problem/1406

=> 

- [x] insert나 erase 후 iterator의 위치는 어떻게 되는지 확인하기
