배경지식

문제해결능력

구현력

-----

# 기초 코드 작성 요령

## 시간, 공간 복잡도

컴퓨터는 1초에 대략 3-5억 개 정도의 연산을 처리할 수 있다. 	

=> 시간 제한이 1초라면, 이는 "당신의 프로그램은 3-5억 번의 연산 안에 답을 내고 종료되어야 한다 " 라는 것

<br>

예를 들어서, 크기가 n인 배열 안에 5의 배수가 몇 개 있는지 알아내는 코드가 있다고 하자.

=> for문과 if문 안의 연산들도 다 자세히 따져보고 계산하면 `5n+3` 의 시간복잡도를 가지지만, 

=> 하지만 이렇게 자세히 다 생각하지 않고, 상수들은 생각하지 않고 적당히 `n`번의 연산이 필요하다고 말할 수 있음.

=> `n` 에 비례한다. 

<br>

#### 시간 복잡도

입력의 크기와 문제를 해결하는데 걸리는 시간의 상관관계 

<br>

#### 빅오표기법

주어진 식을 값이 가장 큰 대표항만 남겨서 나타내는 방법

+ O(N) <= 5N+3, 2N + 10lgN, 10N

+ O(1) <= 5, 16, 36

  

![image-20230306163230668](C:\Users\alsd2\AppData\Roaming\Typora\typora-user-images\image-20230306163230668.png)

문제에서 주어지는 시간 제한은 대부분 1초에서 5초 사이 정도이므로 입력의 범위를 보고 문제에서 요구하는 시간복잡도가 어느 정도인지 알 수 있다. 

주어진 문제를 보고 풀이를 떠올린 후에 무턱대고 바로 그걸 짜는게 아니라 내 풀이가 이 문제를 제한 시간 내에 통과할 수 있는지, 즉 내 알고리즘의 시간 복잡도가 올바른지 생각해봐야 한다. 

=> 그럼 내 알고리즘의 시간 복잡도를 어떻게 알 수 있냐 ?





일단 기본적으로 이렇게 생각할 수 있음 

=> 대충 1부터 N까지의 수를 다 돌아야 하면 O(N), 이중 for문을 돌아야 한다면 O(N^2) 



시간복잡도 연습문제) 

 EX1) N이하의 자연수에서 3의 배수이거나 5의 배수를 모두 합한 값을 반환하는 함수를 작성하라.

```c++
int func1(int N) {
	int sum = 0;
	for (int i = 1; i <= N; i++) {
		if (i % 3 == 0 || i % 5 == 0)
			sum += i;
	}
	return sum;
}
```

for문에서 i가 1부터 N까지 돌면서 3으로 나눠지는지, 5로 나누어지는지 확인하기 때문에 시간 복잡도는 `O(N)`이다. 

​	 

EX3) N이 제곱수이면 1을 반환하고 제곱수가 아니면 0을 반환하는 함수를 작성하라.

```c++
int func3(int N){
	for (int i = 0; i * i <= N; i++) {
		if (i * i == N)
			return 1;
	}
	return 0;
}
```

i가 1,2,3 이렇게 증가하다가 최대 `root N`까지 올라갈테니 시간복잡도는 `O(root N)`이다. 





EX4) N 이하의 수 중에서 가장 큰 2의 거듭제곱 수를 반환하는 함수 

```c++
int func4(int N){
	int i = 1;

	while (i * 2 <= N) {    
		i = i * 2;
	}
	
	return i;
}
```

i가 1로 시작해서 계속 커지다 `lgN`까지 커지기 때문에 시간복잡도는 `O(lgN)`이다. 



#### 공간 복잡도

입력의 크기와 문제를 해결하는데 필요한 공간의 상관관계

메모리 제한이 512MB일 때, int 변수를 대략 1.2억개 정도 선언할 수 있다

=> int 변수 하나가 4byte 이기 때문. 







## 정수 자료형

char 자료형은 1byte = 8bit이다.

=> char 자료형의 값은 8개의 0 혹은 1이 들어가는 칸을 이용해 표현된다. 



short => 2byte

int => 4 byte

long long => 8 byte



short는 딱히 쓸 일이 없고, 정수를 표현할 때 주로 int나 long long을 쓰는데 int가 long long 보다 연산속도와 메모리 모두 우수하지만 int 자료형이 표현할 수 있는 범위를 넘어서는 수를 저장해야 하면 반드시 long long 자료형을 사용해야 한다. 



Integer Overflow 

```c++
int main(){
	int a = 2000000000 * 2; // 20억 * 2
    cout << a;
}

// result
// -294967296
```

int가 대충 20억까지 표현할 수 있다 그랬으니 40억을 표현할 수 없는 건 알겠는데 왜 이런 마이너스 값을 출력하나 ? 

=> 컴퓨터는 이진수로 연산을 하기 때문에 



하지만 실제 코드를 짜다보면 Integer Overflow는 아주 빈번하게 일어나고 찾기도 아주 힘들다.





## 실수 자료형

float => 4byte

double => 8byte



32칸 혹은 64칸으로 실수를 나타내는 건데, 어떻게 표현하는 걸까 ?



참고 사이트

+ https://velog.io/@hyungraelee/%EC%8B%A4%EC%88%98%EC%9D%98-%EB%B6%80%EB%8F%99-%EC%86%8C%EC%88%98%EC%A0%90-%EC%A0%80%EC%9E%A5-%EB%B0%A9%EC%8B%9D
+ https://ahnjg.tistory.com/16





실수의 성질

1. 실수의 저장/연산 과정에서 반드시 오차가 발생할 수 밖에 없다.

   => 웬만하면 `double`로 실수를 사용하는 게 좋음

2. double에 long long 범위의 정수를 함부로 담으면 안된다.

   => double은 유효숫자가 15자리인데 long long은 최대 19자리이기 때문

3. 실수를 비교할 때는 등호를 사용하면 안 된다.

   => 오차 때문에 두 실수가 같은지 알고 싶을 때에는 둘의 차이가 아주 작은 값, 10^-12 이하면 동일하다고 처리 하는게 안전하다. 1e-12가 바로 10^-12 이다. 

