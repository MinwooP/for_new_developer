# DFS

## 알고리즘 설명

#### DFS

=> 다차원 배열에서 각 칸을 방문할 때 깊이를 우선으로 방문하는 알고리즘

=> BFS의 과정에서 **큐**를 **스택**으로만 바꾼 것.

> BFS => 너비를 우선으로 

<br><br>

## 예시

DFS 정석 코드

```C++
#define X first
#define Y second // pair에서 first, second를 줄여서 쓰기 위해서 사용


int board[502][502] =
{ {1,1,1,0,1,0,0,0,0,0},
 {1,0,0,0,1,0,0,0,0,0},
 {1,1,1,0,1,0,0,0,0,0},
 {1,1,0,0,1,0,0,0,0,0},
 {0,1,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0,0} }; // 1이 파란 칸, 0이 빨간 칸에 대응

bool vis[502][502]; // 해당 칸을 방문했는지 여부를 저장
int n = 7, m = 10; // n = 행의 수, m = 열의 수

int dx[4] = { 1,0,-1,0 }; 
int dy[4] = { 0,1,0,-1 }; // 상하좌우 네 방향을 의미

int main(void) {
	ios::sync_with_stdio(0);
	cin.tie(0);
	stack<pair<int, int> > S;

	vis[0][0] = 1; // (0, 0)을 방문했다고 명시
	S.push({ 0,0 }); // 큐에 시작점인 (0, 0)을 삽입.

	while (!S.empty()) {
		pair<int, int> cur = S.front(); 
		S.pop();
		
		cout << '(' << cur.X << ", " << cur.Y << ") -> ";
		
		for (int dir = 0; dir < 4; dir++) { // 상하좌우 칸을 살펴볼 것이다. dir = 0, 1, 2, 3
			int nx = cur.X + dx[dir]; 
			int ny = cur.Y + dy[dir]; // nx, ny에 dir에서 정한 방향의 인접한 칸의 좌표가 들어감
			if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue; // 범위 밖일 경우 넘어감
			if (vis[nx][ny] || board[nx][ny] != 1) continue; // 이미 방문한 칸이거나 파란 칸이 아닐 경우
			vis[nx][ny] = 1; // (nx, ny)를 방문했다고 명시
			S.push({ nx,ny });
		}
	}
}
```

<br><br>

## BFS vs DFS

BFS는 큐를 쓰고, DFS는 스택을 쓴다는 차이가 있지만, 원소 하나를 빼내고 주변을 살펴본다는 알고리즘의 흐름은 똑같다. 하지만 둘의 방문 순서는 차이가 있다.

![image-20230419101253000](C:\Users\alsd2\AppData\Roaming\Typora\typora-user-images\image-20230419101253000.png)

BFS => 가운데서부터 퍼져가는 느낌 => 거리  순으로 방문

DFS => 뭔가 한 방향으로 막힐 때까지 쭉 직진하는 느낌  	

<br>

BFS에서 유용하게 썼던  "현재 보는 칸으로부터 추가되는 인접한 칸은 거리가 현재 보는 칸보다 1만큼 더 떨어져있다"는 성질이 DFS에서는 성립하지 않음

=> 거리를 계산할 때는 DFS를 사용할 수 없음

=> 다차원 배열에서는 굳이 BFS대신 DFS를 써야하는 일이 없음. 

=> 앞으로 다차원 배열에서 순회하는 문제를 풀 때는 계속 BFS만 쓸 것.

=> 나중에 그래프와 트리에서 DFS가 필요하다. 

