# 재귀

## 알고리즘 설명

#### 재귀

하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘

<br>

#### 기본 예시

```c++
void print(int n) {
	if (n == 0) return;
	cout << n << ' ';
	print(n - 1);
}


int sum(int n) {
	if (n == 1) return 1;
	return n + sum(n - 1);
}
```

<br>

우리가 어떤 문제를 재귀로 푼다는 건, 곧 귀납적인 방식으로 문제를 해결하겠다는 것인데, 이 귀납적인 방식이란 게 지금까지의 우리의 상식과는 큰 차이가 있다.

<br>

#### 수학적 귀납법

모든 도미노가 쓰러지는 이유

+ 절차적 사고 : 1번 도미노가 쓰러지면 2번 도미노가 쓰러질 것이고, 2번 도미노가 쓰러지면 3번 도미노가 쓰러지기 때문에 결국 모든 도미노가 쓰러진다.

  => 모든 과정들을 하나씩 따라가면서 생각해보는 것

+ 귀납적 사고 :

  1. 1번 도미노가 쓰러진다.

  2. k번 도미노가 쓰러지면 k+1번 도미노도 쓰러진다

     => 따라서 모든 도미노가 쓰러진다.
  
  => 1, 2번 조건을 만족하면 모든 경우에 대해 성립한다는 것이라고 가정하고(모든 과정을 다 따라가보지 않고)이에 대한 코드를 짜면 된다. 

=> 우리가 당연하게 생각하는 **절차 지향적** 사고를 탈피해야 한다. 

<br>

#### 재귀 함수의 조건

+ 특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 함(Base Condition)

+ 모든 입력은 Base Condition으로 수렴해야 함 

<br>

#### 재귀에 대한 정보 1

+ 함수의 인자로 어떤 것을 받고 어디까지 계산한 후 자기 자신에게 넘겨줄지 명확하게 정해야 함

+ 모든 재귀 함수는 반복문 만으로 동일한 동작을 하는 함수를 만들 수 있음

  => 재귀는 반복문으로 구현했을 때에 비해 코드가 간결하지만 메모리/시간에서는 손해를 봄 

+ 한 함수가 자기 자신을 여러 번 호출하게 되면 비효율적일 수 있음

  ```c++
  int fino(int n){
      if(n<=1) return 1;
      return fibo(n-1) + fibo(n-2);
  }
  ```

+ 재귀 함수가 자기 자신을 부를 때 스택 영역에 계속 누적이 됨

  재귀 함수가 자기 자신을 부를 때 **스택 영역에 함수에 대한 정보가 누적**된다. 이 스택 영역이라고 하는 것은 메모리 구조에서의 스택 영역을 말한다.

  우리가 문제를 풀 때 메모리 제한이라는게 있다. 그 제한이 512MB라고 하면 프로그램이 점유하는 메모리가 최대 512MB여야 하는데, 일부 컴파일 환경에서는 스택 영역의 메모리가 별도로 1MB로 제한되어 있기도 합니다. 엄밀히 말해 Visual Studio 2017/2019에서도 별도로 설정을 안하면 1MB이고 GCC+MingW도 1MB이고 리눅스의 경우 버전에 따라 차이가 있긴 하지만 8MB 혹은 10MB와 같이 제한이 걸려있습니다. 그리고 채점 사이트 중에서도 설정을 따로 바꾸지 않아 스택 메모리의 제한이 문제의 메모리 제한과 별도로 작게 걸려있는 경우가 있습니다.

  BOJ는 스택 메모리의 제한이 없지만 현재(2020년 6월) 기준 swexpertacademy.com 에는 제한이 걸려 있습니다. 그래서 지금 이 코드처럼 재귀를 한 10만번 정도만 들어가도 스택 메모리에 함수에 대한 정보가 계속 쌓이다가 1MB를 넘겨서 제출해보면 런타임 에러가 발생합니다. 만약 swexpertacademy.com 과 같이 스택 메모리가 작게 제한된 곳에서 문제를 푸는데 본인의 풀이가 재귀를 깊게 들어가는 풀이라면 어쩔 수 없이 재귀 대신 반복문으로 문제를 풀어야합니다. 참고로 스택 메모리에는 지역 변수도 들어갑니다.

  그리고 BOJ에 제출하면 "맞았습니다"가 뜨는 남의 코드를 로컬에서 돌렸을 때 계속 런타임에러가 나는 일을 겪어보신 분이 있을텐데 가장 의심해볼만한건 재귀가 너무 깊거나 지역 변수로 int arr[2000][2000]과 같 큰 배열을 잡았지 않았을까 하는 것입니다. int 400만개면 벌써 16MB를 잡아먹기 때문입니다. 만약 본인의 개발 환경에서 슬라이드 상의 저 코드를 실행했을 때 정상적으로 동작하지 않는다면 구글 검색을 통해 스택 메모리 제한을 해제해두시는걸 추천드립니다.

<br><br>

## 연습문제 1 - 거듭제곱_1629

 A <sup>B</sup> Mod C를 구하는 문제

=> 상식적으로는 A를 B번 계속 곱하고, 그 결과를 C로 나눈 나머지를 구하면 됨

=> 하지만 A,B,C의 범위가 2,147,483,647이므로  A <sup>B</sup> 은 int의 범위를 넘어갈 수 있다.(Integer Overflow)  따라서, A를 B번 다 곱한 다음 C로 나누는 게 아니라, 곱하는 중간중간 C로 나눠주고, 이것끼리 곱해도 결과는 같음(mod 연산이므로)

=> 이렇게 계산한다면 크게 보면 A를 B번 곱하는 것이므로 `O(B)`의 시간 복잡도를 갖게 된다. B가 21억이라면 문제에서 주어진 시간을 넘기므로 다른 방법이 필요 	

<br>

+ a<sup>n</sup> x a<sup>n</sup>  =  a<sup>2n</sup> 
+ 12<sup>58</sup> = 4 (mod 67) => 12<sup>116</sup> = 16(mod 67)

위의 두 가지 성질을 이용해

a<sup>2n </sup> mod c을 구하고 싶을 때, a<sup>n</sup> x a<sup>n</sup> mod c 를 구하면 된다. 

<br>

> 도미노 예시에서의 귀납적인 사고 
>
> + 1번 도미노가 쓰러진다.
> + k번 도미노가 쓰러지면 k+1번 도미노도 쓰러진다.
>
> 를 이번 문제에 적용하면
>
> + 1승을 계산할수 있다. 
> + k승을 계산했으면 2k승과 2k+1승도 O(1)에 계산할 수 있다. 

<br>

솔루션 코드

```c++
using ll = long long;
ll POW(ll A, ll B, ll C) {
		if (B == 1) 
			return A % C;
		ll val = POW(A, B / 2, C);
		val = val * val % C;
	
		if (B % 2 == 0)
			return val;
		else
			return val *  A % C;
	}
```

=> 이 함수의 시간 복잡도는 b가 계속 절반씩 깎이기 때문에 `O(log b)`이다. 

<br><br>

## 연습문제 2 - 하노이탑_11729 다시풀기

중요한 건 => 귀납적 사고 !!

귀납적 사고란 ?

=> `k = 1`일 때 성립, k일 때 성립하면 k+1일 때 성립. 이 두가지 조건을 만족하면 모든 경우에 대해 만족하는 것.

<br>

#### 1. 귀납적 사고 확인

![image-20230420200704163](C:\Users\alsd2\AppData\Roaming\Typora\typora-user-images\image-20230420200704163.png)

결국 모든 원판들을 전부 기둥 1 => 기둥 3으로 옮기려면 n번 원판을 기둥1 => 기둥3 으로 옮겨야 한다. 

=> 그런데 n번 원판을 움직이려면 n번 원판 위 1~n-1번 원판들이 전부 비켜줘야 하고, 더 나아가 이들은 전부 기둥2로 가야함.(작은 원판 위에 큰 원판을 둘 수 없다는 규칙 때문에 n번 원판이 기둥3으로 가기위해서)

그래서, 전체 단계는 아래와 같이 되고,

1. `1 ~ n-1`번 원판들은 기둥1 => 기둥 2 

2. `n`번 원판은 기둥1 => 기둥3
3. `1~n-1`번 원판들 기둥2 => 기둥3 

이를 통해서 알 수 있는 것은, **n-1개의 원판을 원하는 곳으로 옮길 수 있다면,  n개의 원판을 옮길 수 있다**는 것이다. (왜냐? 위의 과정에서 필요한 행동은  `1~n-1`번 원판을 옮기는 것과 `n`번 원판을 옮기는 것인데, `n`번 원판을 옮기는 것은 기둥1에서 아무것도 없는 기둥3으로 원판 하나만 옮기는 것이기 때문에, 자명하게 가능하다. 따라서 n-1개의 원판만 옮길 수 있다면, n개도 가능)

<br>

위의 내용을 바탕으로,

1. 원판이 1개일 때, 원판을 내가 원하는 곳으로 옮길 수 있다,
2. 원판이 k개일 때 옮길 수 있으면 원판이 k+1개일 때에도 옮길 수 있다.

위 두 사실을 알 수 있으므로, 모든 원판을 옮길 수 있음을, 즉, 귀납적으로 이 문제를 풀 수 있음을 알 수 있다. 

<br>

#### 2. 재귀 코드 작성

이제 코드를 작성할텐데,

1. 함수의 정의
2. base condition
3. 재귀 식 

을 step by step으로 해보자.

<br>

##### 1.함수의 정의

함수를 정의한다는 건, **함수가 어떤 역할을 수행**하는지, **어떤 인자를 받는지**를 정하는 것. 

일단 쉽게 생각할 수 있는 형태는 

`void func(int n)`

=> 원판 n개를 기둥 1에서 기둥 3으로 옮기는 방법을 출력하는 함수 인데,

재귀가 늘 그렇듯 우리는 `func(n)`내 에서 `func(n-1)`를 호출해야 하는데, 여기 `func(n)` 함수에 결함이 있다. 

이는 바로, `func(n)` 함수는 원판 n개를 기둥 1 => 기둥 3으로 옮기는 역할인데, 여기서 n-1개를 기둥 1 => 기둥 3으로 옮기는 게 아니라, 기둥2로 옮겨야 하는데, 현재 함수의 형태 `func(n-1)`만을 보고는 기둥2로 옮기는지, 기둥3으로 옮기는지에 대한 정보를 나타내줄 수, 판단할 수 없다.

따라서, 시작 기둥과 도착 기둥도 인자로 받는 새로운 형태의 함수를 정의해야 한다.

`void func(int a, int b, int n)`

=> 원판 n개를 기둥a에서 기둥b로 옮기는 방법을 출력하는 함수

<br>

##### 2. Base condition

함수의 정의를 생각했으니, 이제 base condition을 생각해보자. 

n = 1일 때는, 원판이 하나 뿐이므로, 기둥a => 기둥b 로 그냥 옮기기만 하면 된다. 

=>

```c++
if(n==1)
    cout << a << ' ' << b << '\n';
```

<br>

##### 3. 재귀식 

이제 재귀 식을 생각해보자. 

만약 `f(1, 3, 3)`이라면, 즉 3단 하노이탑을 기둥 1에서 기둥 3으로 옮기는 상황이라면,

1. 1,2번 원판을 기둥 1 => 기둥 2로 옮기고 
2. 3번 원판을 기둥 1 => 기둥 3으로 옮기고
3. 기둥 2에 있던 1,2번 원판을 기둥 3으로 옮겨야 한다. 

위의 각 단계를 코드로 표현해보면

1. `f(1, 2, 2)` 

   => 2개의 원판을 원래 있던 기둥 1 => 기둥 2 (기둥1도 아닌, 기둥3도 아닌 남은 기둥)으로 옮긴다

2. `f(1, 3, 1)` 

   => 1개의 원판을 원래 있던 기둥 1 => 기둥 3 으로 옮긴다. 

3. `f(2, 3, 2)`

   => 2개의 원판을 기둥2 => 기둥3 으로 옮긴다.

가 되고, 이를 일반화 하면 아래와 같이 표현할 수 있다. 아래에서 `6-b-a`는 3개의 기둥 중, 기둥a도 기둥 b도 아닌 기둥을 의미한다.

```c++
f(a, b, n) =>
    
f(a, 6-b-a, n-1);
f(a, b, 1);
f(6-b-a, b, n-1)
```

<br>

#### 3. 실제 코드

```c++
void func(int a, int b, int n){
  if(n == 1){
    cout << a << ' ' << b << '\n';
    return;
  }
  func(a, 6-a-b, n-1);
  cout << a << ' ' << b << '\n';
  func(6-a-b, b, n-1);
}

int main(void){
  ios::sync_with_stdio(0);
  cin.tie(0);
  int k;
  cin >> k;
  cout << (1<<k) - 1 << '\n';
  func(1, 3, k);
}
```

그리고 문제에서는 총 옮긴 횟수도 같이 물어보고 있는데 원판 k개를 옮기기 위해 A번 이동이 필요했다고 하겠습니다. 그러면 원판 k+1개를 옮길 때는 k개의 원판을 빈 곳으로 옮길 때 A번, k+1번 원판을 옮길 때 1번, k개의 원판을 다시 빈 곳에서 목적지로 옮길 때 A번이 필요하니 2A+1번 이동이 필요함을 알 수 있습니다. 더 나아가 초항이 1이기 때문에 이 수열의 일반항은 2k-1이 되긴 하는데 하노이 탑은 워낙 유명한 문제이니 지금처럼 횟수를 물어보지만 코딩 테스트에서 이러한 지식이 필요한 일은 없을거라 일반항을 유도하는 방법은 몰라도 괜찮습니다.

[코드](https://github.com/encrypted-def/basic-algo-lecture/blob/master/0x0B/11729.cpp)를 같이 보겠습니다. 앞의 슬라이드에서 부분 부분 쪼개 설명을 다 했어서 크게 다시 설명할 부분은 없는데 다만 18번째 줄에서 (1<<k)가 조금 어색할 수 있겠다 싶습니다. << 이건 left shift라고 불리는 비트 연산자인데 1을 비트 기준 왼쪽으로 k칸 밀어라는 의미이기 때문에 (1<<k)는 2k가 됩니다.

왜 이게 올바른 답을 내냐는 질문에 대해 예를 들어 func(1, 3, 5)를 부르면 func(1, 3, 5)는 func(1, 2, 4)를 부르고 func(1, 2, 4)는 func(1, 3, 3)을 부르고… 이렇게 생각하기 시작하면 무간지옥에 빠졌습니다. 머릿 속은 꼬이고 감도 안올것입니다. 이렇게 함수를 계속 따라들어가면 답이 없고 그냥 딱 귀납적으로 생각을 하면 됩니다. 일단 n = 1일 때 잘 동작합니다. 그냥 a b를 출력하니 이건 정말 자명합니다. 그리고 n = k일 때 잘 동작한다고 치면 n = k+1일 때에도 잘 동작합니다. 아마 이건 충분히 납득할 수 있을 것입니다. 그러면 마치 1번 도미노를 쓰러트리면 모든 도미노가 다 쓰러지는 것과 같이 n = 1, 2, 3, 4… 이렇게 모든 n에 대해 이 함수는 잘 동작합니다.

<br><br>

## 연습문제 3 - Z _1074

꽤 생각을 해봤고, 내 풀이도 올바른 출력을 냈지만, 시간 초과였다. 

4등분 하면서 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른족 아래 순서로 방문하는 재귀적 규칙을 찾았고, 이를 이용해 4등분 하면서 모든 이중 배열을 방문하면서 카운트를 1씩 증가시키고, 입력된 위치 r,c에 도달할 때 카운트 값을 출력시키도록 했다.

하지만 이렇게 모든 칸을 방문하기에는 시간이 오래걸렸고, 나도 각 4등분 한 상자들을 skip해도 된다는 사실은 알았지만, 이를 구현하기에는 쉽지 않았다.

구현하지 못한 이유 중 하나는, 함수의 정의를 

```c++
void f(int n, int a, int b) {
	if (n == 1) {
		for (int i = a; i < a + 2; i++) {
			for (int j = b; j < b + 2; j++) {
				if (r == i && c == j) {
					cout << cnt;
					exit(1);
				}
				else {
					cnt++;
				}
			}
		}
		return;
	}
	else {
		f(n - 1, a, b );	
		f(n - 1, a, b + (1 << (n - 1)));
		f(n - 1, a + (1 << (n - 1)), b);
		f(n - 1, a + (1 << (n - 1)), b + (1 << (n - 1)));
	}
}
```

이런 식으로 인자에 `f(n, a, b)`를 넘겨줌으로써, a,b를 기준으로 모든 칸을 방문하도록 했기에, skip을 구현하기 쉽지 않았던 것 같다.

<br>

솔루션 코드

```c++
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <climits>
#include <cstring>
#include <string>
#include <vector>
#include <queue>
#include <deque>
#include <stack>
#include <map>
#include<iomanip>
using namespace std;
using ll = long long;

int Z(int n, int r, int c) {
	if (n == 0)
		return 0;

	int half = (1 << (n - 1));
	int skip = half * half;
	if (r < half && c < half) return Z(n - 1, r, c);
	if (r < half && c >= half) return skip + Z(n - 1, r, c - half);
	if (r >= half && c < half) return 2 * skip + Z(n - 1, r - half, c);
	if (r >= half && c >= half) return 3 * skip + Z(n - 1, r - half, c - half);
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int N, r, c;
	cin >> N >> r >> c;
	cout << Z(N, r, c);

	return 0;
}
```

<br>

##### 1. 함수의 형태

직관적으로 보이는 모양대로 정의하면 된다.

```c++
int func(int n, int r, int c)
```

=> 2<sup>n</sup> x 2<sup>n</sup> 배열에서 (r,c)를 방문하는 순서를 반환하는 함수



##### 2. base condition

`if(n == 0) return 0;`

n = 1일 때로 잡아도 되지만, 그러면 base condition에서 별도의 처리가 필요함



##### 3. 재귀 식

(r, c)가 1번 사각형일 때, 2번 사각형일 때, 3번 사각형일 때, 4번 사각형일 때의 상황을 나눠서 정의.



-----

#### 참고

재귀 알고리즘이 실제로 작동하려면 범위가 더 좁은 하위 문제가 base case에 도달하여 재귀함수가 끝날 수 있어야 합니다. n!을 계산할 때, 하위 문제는 점점 작아져 0!에 도달합니다. 이런 base case 가 *반드시* 있어야 합니다



재귀의 반복 개념은 다음과 같이 두 개의 간단한 규칙으로 간추릴 수 있습니다.

1. 재귀의 호출은 같은 문제 내에서 더 범위가 작은 값, 즉, 하위 문제에 대해 이루어져야 한다.
2. 재귀함수 호출은 더 이상 반복되지 않는 base case에 도달해야 한다.



완전 탐색을 할 때 사용할 수 있는 방법 중 하나 