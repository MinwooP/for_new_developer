# [4179번_불!](https://www.acmicpc.net/problem/4179)

##  Category : 바킹독 - BFS

## 🎖정답과 내 풀이 비교

내 풀이)

처음에 먼저 J와 F 노드들 모두 큐에 넣어서 동시에 BFS 돌림

=> 하지만 J먼저 넣어서, 항상 J가 한 템포 앞서도록



POP하고 상하좌우 PUSH 판단할 때, 

J를 POP 할 때,

`.` => J로 바꿔서 push

`J, #, F ` => push 하지 않고, continue;

가장 자리 까지 갈 경우, 탈출 성공 => J를 PUSH 할 때마다 Time 배열의 j위치에 t 기록해줌



F를 pop할 때, 

 `.  , J`  => F로 변경(확산되므로)

`#, F` => Q에 넣지 X



이렇게 동시에 돌리고, J가 가장자리에 도달하는 순간 BFS 중지



솔루션)

너무 복잡하게 생각한 것이었다

=> J를 POP하는 과정과 F를 POP하는 과정이 겹쳐서 이를 어떻게 할지 고민이엇는데

=> J에 대한 BFS와 F에 대한 BFS를 각각 다른 배열에서 돌리면 됐었다. 다른 배열에서 돌리긴 하지만, J에 대한 BFS를 돌릴 때, F의 BFS를 돌리는 배열을 참고해서, 불이 있는 칸에 대해서는 push하지 않고, continue 해주면 될 것이다. 



=> 먼저 불에 대한 BFS를 돌려서, 미리 각 칸에 불이 전파되는 시간을 다 구해둔다. 

그다음에는 J에 대한 BFS를 돌리면서 ,지훈이를 이동시키는데 지훈이가 특정 칸을 X시간ㅇ ㅔ최초로 방문할 수 잇는데, 그 칸에는 X시간이나 그 이전에 불이 붙는다면 그 칸을 못가게 되는 것.



```
4 5
##.##
#J.F#
#...#
#...#



t_F
-1 -1 2 -1 -1
-1 2  1  0 -1
-1 3  2  1 -1
-1 4  3  2 -1

t_J
-1 -1 -1 -1 -1
-1 0  -1 -1 -1
-1 -1 -1 -1 -1
-1 -1 -1 -1 -1


M_F
4 5
##.##
#210#
#321#
#432#
```





<br><br>

## 🎖 핵심 아이디어



<br><br>

-----

## 🎖 전체 코드

### My code

```c++

```

<br>

<br>

### Solution code

```c++

```