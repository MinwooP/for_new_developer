# BFS

## BFS란?

다차원 배열에서 각 칸을 방문할 때 너비를 우선으로 방문하는 알고리즘



## 예시 

### EX1)

좌표상에서 (0,0)과 상하좌우로 이어진 모든 파란색 칸을 확인하는 것

1. 시작하는 칸을 큐에 넣고, 방문했다는 표시를 남김
2. 큐에서 원소를 꺼내어 그 칸에 상하좌우로 인접한 4칸에 대해 3번을 진행
3. 해당 칸을 이전에 방문했다면 아무것도 하지 않고, 처음으로 방문했다면 방문했다는 표시를 남기고 해당 칸을 큐에 삽입
4. 큐가 빌때까지 2번을 반복

모든 칸이 큐에 1번씩 들어가므로 시간복잡도는 칸이 N개일 때 O(N)

만약 행이 R개이고 열이 C개이면 O(RC)가 될 것이다.



보통 BFS에서는 (a, b)에서 a가 행, b가 열을 의미한다.

(0,0) (0,1) (0,2) (0,3)

(1,0) (1,1) (1,2) (1,3)

(2,0) (2,1) (2,2) (2,3)



### BFS 대표적 구현 예시

```c++
#define X first
#define Y second // pair에서 first, second를 줄여서 쓰기 위해서 사용


int board[502][502] =
{ {1,1,1,0,1,0,0,0,0,0},
 {1,0,0,0,1,0,0,0,0,0},
 {1,1,1,0,1,0,0,0,0,0},
 {1,1,0,0,1,0,0,0,0,0},
 {0,1,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0,0} }; // 1이 파란 칸, 0이 빨간 칸에 대응

bool vis[502][502]; // 해당 칸을 방문했는지 여부를 저장
int n = 7, m = 10; // n = 행의 수, m = 열의 수

int dx[4] = { 1,0,-1,0 }; 
int dy[4] = { 0,1,0,-1 }; // 상하좌우 네 방향을 의미

int main(void) {
	ios::sync_with_stdio(0);
	cin.tie(0);
	queue<pair<int, int> > Q;

	vis[0][0] = 1; // (0, 0)을 방문했다고 명시
	Q.push({ 0,0 }); // 큐에 시작점인 (0, 0)을 삽입.

	while (!Q.empty()) {
		pair<int, int> cur = Q.front(); 
		Q.pop();
		
		cout << '(' << cur.X << ", " << cur.Y << ") -> ";
		
		for (int dir = 0; dir < 4; dir++) { // 상하좌우 칸을 살펴볼 것이다. dir = 0, 1, 2, 3
			int nx = cur.X + dx[dir]; 
			int ny = cur.Y + dy[dir]; // nx, ny에 dir에서 정한 방향의 인접한 칸의 좌표가 들어감
			if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue; // 범위 밖일 경우 넘어감
			if (vis[nx][ny] || board[nx][ny] != 1) continue; // 이미 방문한 칸이거나 파란 칸이 아닐 경우
			vis[nx][ny] = 1; // (nx, ny)를 방문했다고 명시
			Q.push({ nx,ny });
		}
	}
}
```

```c++
		x-1, y
x,y-1   x, y   x, y+1
        x+1, y
            
            
x : 행
y : 열
```



### EX2

BOJ_1926번_그림

이 문제를 위해 구현해야 할 것

1. 상하좌우로 연결된 그림의 크기를 알아내기
2. 도화지에 있는 모든 그림을 찾아내기

이중 포문을 돌면서 BFS의 시작점이 될 수 있는 곳을 찾으면 된다 .





## 연습문제 풀이

#### 연습문제1 : 거리측정  => 2178_미로탐색

+ 미로의 좌측상단으로부터 우측 하단으로 가는 최단경로의 길이를 찾는 문제
+ BFS를 이용해 시작점에서 연결된 다른 모든 점으로의 최단 경로를 찾을 수 있다. 

=> 

정석 BFS + `vis[][]`를 사용하는게 아닌 거리를 담는 배열 `dist[][]`를 사용

<br>

#### 연습문제2:  시작점이 여러개일 때 => 7576_토마토

+ 토마토가 익어가는 상황 자체가 BFS를 하는 것과 똑같기도 하고, 
+ 토마토가 다 익기까지 필요한 최소 일수를 구하려면 모든 익지 않은 토마토들에 대해 가장 가깝게 위치한 익은 토마토까지의 거리를 구해야 한다는 관점에서 살펴봐도

BFS를 활용하는 것이 좋을 것임



익은 토마토의 개수가 여러개일 수 있으니, **각 익은 토마토들에 대해 해당 위치를 시작점으로 하는 BFS를 한 번 씩 다 돌리는 방법**을 떠올릴 수 있지만, 그러면 BFS의 시간복잡도가 O(NM)이고 익은 토마토 또한 최대 NM개가 있을 수 있으니 시간 복잡도가 총 O(N<sup>2</sup>M<sup>2</sup>)이 되어 시간내로 해결이 되지 않는다.



즉, 시작점이 여러개인 BFS를 돌 수 있어야 하는데, 이는 각 시작점(익은 토마토)들을 먼저 다 찾아놓고, 이들을 한꺼번에 큐에 넣어서 BFS를 돌리면 가능하다. 



#### 연습문제3 : 시작점이 두 종류일 때 => 4179_불





