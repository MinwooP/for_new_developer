## Priority queue



### 우선순위 큐란?

+ **큐(Queue)**는 먼저 들어오는 데이터가 먼저 나가는 **FIFO(First In First Out)** 형식의 자료구조이다.

+ **우선순위 큐(Priority Queue)**는 먼저 들어오는 데이터가 아니라, 우선순위가 높은 데이터가 먼저 나가는 형태의 자료구조이다.
+ 우선순위 큐는 일반적으로 **힙(Heap)**을 이용하여 구현한다.



### 힙이란?

+ **힙(Heap)**은 우선순위 큐를 위해 고안된 완전이진트리 형태의 자료구조이다. 여러 개의 값 중 최댓값 또는 최솟값을 찾아내는 연산이 빠르다.

+ 힙의 특징
  + **완전이진트리** 형태로 이루어져 있다.
  + 부모노드와 서브트리간 대소 관계가 성립된다. (반정렬 상태)
  + 이진탐색트리(BST)와 달리 중복된 값이 허용된다.





### 우선순위 큐 ADT

+ 객체 : 우선순위를 가진 요소들의 모음
+ 연산
  + insert(x) : 우선순위 큐에 요소 x를 추가
  + remove() : 우선순위 큐에서 가장 우선순위가 높은 요소를 삭제하고 반환
  + find() : 우선순위 큐에서 가장 우선순위가 높은 요소를 반환 

+ 구현

  힙은 일반적으로 배열을 이용하여 구현한다. 





구현

1. 힙 구현

   힙은 일반적으로 배열을 이용하여 구현한다. 완전 이진트리이므로 중간에 비어있는 요소가 없기 때문이다. 

   <img src="https://user-images.githubusercontent.com/31370590/143538213-1e0aae64-a01e-455b-b4cc-2bb7151e0577.PNG">

   위 그림과 같이 트리의 각 노드에 번호를 붙이고, 이 번호를 배열의 인덱스로 생각하면 효과적으로 힙을 구현할 수 있다. 배열로 구현하였기 때문에 부모 또는 자식을 찾아가는 연산을 구현하기도 편리하다.  

   + 자식 노드를 구하고 싶을 때
     + 왼쪽 자식노드 index = (부모노드 index) * 2
     + 오른쪽 자식노드 index = (부모노드 index) * 2 + 1
   + 부모 노드를 구하고 싶을 때
     + 부모노드 index = 자식노드 index / 2

2. 삽입 연산

   힙에 삽입을 하기 위해서는 힙 트리의 성질을 만족시키면서 새로운 요소를 추가해야 한다.

   **삽입 방법**

   1. 우선 완전이진트리의 마지막 노드에 이어서 새로운 노드를 추가한다.
   2. 추가된 새로운 노드를 부모의 노드와 비교하여 교환한다.
   3. 정상적인 힙트리가 될 때 까지 (더이상 부모노드와 교환할 필요가 없을 때까지) 2번을 반복한다.

    => 

   최악의 경우 새로 추가된 노드가 루트노트까지 비교하며 올라가야 하므로 시간복잡도가 `O(log₂n)`이다.



3. 삭제 연산

   힙 트리에서 루트노드가 가장 우선순위가 높으므로 루트 노드를 삭제해야 한다. 삭제가 이뤄진 후 힙 트리의 성질이 유지돼야 하므로 아래와 같은 방법으로 삭제를 진행한다.

   **삭제 방법**

   1. 루트 노드를 삭제한다.
   2. 루트 노드가 삭제된 빈자리에 완전이진트리의 마지막 노드를 가져온다.
   3. 루트 자리에 위치한 새로운 노드를 자식 노드와 비교하여 교환한다.
      이때 최대 힙인 경우 자식노드 중 더 큰 값과 교환을 하며, 최소 힙인 경우 더 작은 값과 교환을 한다.
   4. 정상적인 힙트리가 될 때까지 (더 이상 자식노드와 교환할 필요가 없을 때까지) 3번을 반복한다.

    =>

   삭제 연산 또한 최악의 경우 루트노트부터 가장 아래까지 내려가야 하므로 시간복잡도가 `O(log₂n)`이다.

   