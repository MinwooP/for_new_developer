# 기초 수학



## 최대공약수

+ GCD

+ 두 수 A와 B의 최대 공약수 G는 A과  B의 공통된 약수 중에서 가장 큰 정수이다.  이를 구하는 방법은 2부터 ```min(A,B)```까지 모든 정수로 나누어 보면 된다. 

  ```c++
  int g = 1;
  for(int i=2; i<min(a,b); i++){
      if(a % i == 0 && b % i == 0){
          g = i;
      }
  }
  ```

+ 최대 공약수가 1인 두 수를 서로소(Coprime)라고 한다.

+ **유클리드 호제법**(더 빠른 방법)

  + a를 b로 나눈 나머지를 r이라고 했을 때, **GCD(a, b) = GCD(b, r)** 이다. r이 0이면 그 때, b가 최대 공약수이다.
  + GCD(24, 16) = GCD(16, 8) = GCD((8, 0))

+ 세 수의 최대 공약수는, 먼저 두수의 최대공약수를 구하고, 나머지 한 수와의 최대공약수를 구하는 방식으로 계산하면 된다. 

+ **GCD함수 구현**

  ```c++
  int gcd(int x, int y){
      if(y==0)
          return ;
      else
          return gcd(y, x%y);
  }
  ```

  



## 최소공배수

+ LCM
+ 두 수의 공통된 배수 중에서 가장 작은 정수를 말하고, GCD를 응용해서 구할 수 있다. 
  + 두 수 A, B의 최대 공약수를 g라고 했을 때, 최소공배수 LCM(A, B) =  **g * (a/b) * (b/g)** 이다. 





## 소수

+ 약수가 1과 자기 자신 밖에 없는  수, 즉 2부터 n-1 까지의 수로 나누어 떨어지지 않으면(그 나머지가 0이 아니면) 그 수는 소수이다.  

+ 소수를 찾는 2가지 방법

  1. 어떤 수 N이 소수인지를 판단

     + 소수의 정의 이용

       N이 소수라면, 2부터 N-1까지의 수로 나눠서 나누어 떨어지지 않는지 판단 -> **O(N)**

     + 약수의 특징 이용

        1과 N이 아닌 수 중, 약수가 될수 있는 수 중 가장 작은 수는 2이다. 그리고 이에 짝을 이루는 N/2이 가장 큰 수이다. 따라서, 2와 N/2 까지의 수로 나눠서 나누어 떨어지지 ㅇ않는지 판단해보면 됨(N/2+1 ~ N-1) 까지는 계산해볼 필요가 없음. -> O(2/N) = **O(N)**

     + 2부터 \sqrt{2} 까지의 수로 나누어 떨어지는지 아닌지 검사  -> **O(\sqrt{N})**

       ```c++
       bool prime(int n){
           if(n < 2){
               return false;
           }
           for(int i=2;i*i<=n;i++){ 
               if(n % i == 0){
                   return false;
               }
           }
           return true;
       }
       ```

       컴퓨터에서 실수는 근사값을 나타내기 때문에, i<루트n 이라고 표현하는 것보다 **i * i < n**으로 나타내는 것이 좋다. 

     

  2. N이하의 모든 소수를 구함

     +  에라토스테네스의 체

       1. 2부터 N까지 모든 수를 써놓는다.
       2. 아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다.
       3. 그 수는 소수이다.
       4. 이제 그 수의 배수를 모두 지운다.(지울때, 어떤 수의 제곱부터 시작해서 지우면 된다. 그전의 그 수의 배수는 전단계들에서 지워졌음이 보장되기 때문에)

       ```c++
       // 구현 시 1) 수를 지웠는지 아닌지에 대한 배열 - 지움 : TRUE
       // 		  2) 소수의 목록을 유지하는데에 대한 배열 
       // 총 2개의 배열이 필요
       
       int prime[100]; // 소수 저장
       int pn = 0; // 소수의 개수
       bool check[101]; // 지워졌으면 true, 
       
       int n = 100; // 100까지의 소수를 구함
       
       check[0] = check[1] = true;
       
       for(int i=2;i<=n;i++){
           if(check[i] == false){
               prime[pn++] = i;
               for(int j = i*i; j<n; j+=i){
                   check[j] = true;
               }
           }
       }                                    
       ```

       

##  골드바흐의 추측

+ __2보다 큰 모든 짝수는 두 소수의 합으로 표현 가능하다.__
+ 위의 문장에 3을 더 하면 
+ 5보다 큰 모든 홀수는 세 소수의 합으로 표현 가능하다. 로 바뀐다.   

+ ex) 6588번_골드바흐의 추측 풀어보기

  ```c++
  ```

  



