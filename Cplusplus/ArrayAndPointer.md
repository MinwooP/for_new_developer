# Array & Pointer

## 배열의 이름

+ 배열의 이름은 **배열의 시작 주소를 가지고 있는 상수 포인터**이다.

  ```c++
  #include <iostream>
  using namespace std;
  
  int main(){
      int arr[] = {1, 2, 3};
      cout << arr << endl;     // 004FF998   arr
      cout << *arr << endl;    // 1
      cout << arr[0] << endl;	 // 1
      cout << &arr << endl;	 // 004FF998  &arr
      cout << &arr[0] << endl; // 004FF998
  }
  ```

  + 여기서, `arr`의 값과 `&arr`의 값이 같은 것을 볼 수 있다. `arr`이 포인터 변수라면,(정확히는 포인터 상수) **`arr`의 주소값(포인터변수 `arr`의 주솟값)**과 **`arr`이 가진 값(`arr`의 주소에 들어있는 값)**이 어떻게 동일할 수 있는가?

    `arr`과 `&arr`은 같은 값을 가지고 있어 동일해보이지만, 사실 동일하지 않다. **서로 다른 타입**을 가지고 있기 때문이다.

    ```c++
    #include <iostream>
    using namespace std;
    
    int main(){
        int arr[] = {1, 2, 3};
        cout << arr << endl;      // 004FF998
        cout << arr + 1 << endl;  // 004FF998 + 4
        cout << &arr + 1 << endl; // 004FF998 + 12 
    }
    ```

  + 만약, `arr`과 `&arr`이 서로 같다면, 즉 값도 같고 타입도 같다면, `arr+1`과 `&arr+1`의 값이 같아야 한다. 

  + `arr + 1`의 값이 `arr`에 비해 4byte 만큼 차이가 난 것은 **arr이 int형 포인터**이기 때문이다. 따라서, `arr + i`의 연산은 `&arr[i]`와 같다.  

  + `&arr + 1`의 값이 12byte 만큼 차이가 난 이유는 `&arr`에서 `arr`는 이 배열 오브젝트 자체를 의미함을 알 수 있다. **배열 요소들에 대한 포인터가 아니라, 배열 그 자체에 대한 포인터**인 것이다. 

  + 즉, **`arr`와 `&arr`의 값은 똑같지만 의미하는 것은 다르다.** &arr에서 arr는 이 배열 오브젝트 그 자체의 주소를 의미하니 **배열포인터에 대입**할 수 있다. 

  + *** `&arr`의 값은 4byte 주소값이지만, 크기는 배열 오브젝트 전체에 대한 크기이므로 배열의 원소의 개수 x 원소의 자료형의 크기가 된다.***

    ```c++
    int main(){
        int arr[10] = {1, 2, 3};
        int (*ptr)[10] = &arr;     // 배열 포인터
        cout << &arr << endl;	   // 004FF998
        cout << ptr << endl;	   // 004FF998
        cout << sizeof(arr) << endl;   // 40
        cout << sizeof(*ptr) << endl;  // 40
        
        cout << sizeof(&arr) << endl;  // 4 ? 
        /* 아니, arr은 배열의 시작주소를 가리키는 상수 포인터이므로 이 주소값의 크4기는 4byte이고, &arr은 배열 오브젝트 전체를 가리키니까 이 크기는 40이 되어야하지 않나 왜 반대인가 */	
    }
    ```
    
    결국, 배열 포인터 `prt`과 `&arr`은 같은 것을 가리키고 있음을 알 수 있다. 
  
  ###### => 최종 정리 : arr은 배열의 시작주소를 가지고 있는 상수 포인터이고, &arr은 배열 오브젝트 전체를 가리키는 포인터다.

   <br>

  ##### Q)

  `int arr[3] = {1, 2, 3};`라는 배열에 대해, 
  
  arr + 1 하면, 4byte가 증가하고,  &arr + 1 하면 12byte가 증가하는데
  sizeof(arr)  = 12 이고, sizeof(&arr) = 4 인게 이해가 가지 않는다. &arr가 배열 전체를 가리키는데 왜 오히려 sizeof 연산을 통해서는 반대인 결과가 나오는 것일까?
  
  #####  A) 
  
  우선, 포인터 변수의 sizeof 연산값은 모두 4byte이다(32bit에서). 이와 같은 맥락으로 &arr는 배열 전체를 가리키는 포인터? **배열 포인터에 대입될 수도 있기 때문에**,  sizeof(&arr) 연산을 하면 4byte가 나오는 것 같고, sizeof(arr)는 배열 전체의 크기를 나타내기 위한? 연산의 느낌이 강하기 때문에 배열 전체의 크기를 출력해주는 것 같다. 

<br>

<br>

## 포인터 배열

+ 포인터배열 : 포인터의 **배열**로, 포인터들이 들어있는 배열.

  ex) 정수형 배열 => `int arr[3];`

  ​	  **포인터형** 배열 => `int* prtary[3]; `	

  <img src = "https://user-images.githubusercontent.com/31370590/127542065-142a66a7-9bb8-48f4-9cbf-ca81883966da.PNG" width = "500" height = "300">

+ 배열의 원소 접근, 이에 저장된 주소 역참조

  ```c++
  int main() {
      int a = 10, b = 20 ,c = 30;
      int* ptrary[3] = {&a, &b, &c};
      
      cout << ptrary[1] << endl;  // 004FF998 현재 포인터 배열이므로 주솟값 출력
      cout << *ptrary[1] << endl; // 20
      
      cout << sizeof(ptrary) << endl; // 12 = 4(pointer의 크기) * 3 
  }
  ```

  + `sizeof(ptrary)`를 하면 `prtary`는 포인터형 배열 전체를 가리키기 때문에, 배열 전체의 크기를 출력해준다. 

  + 배열의 원소에서 역참조를 할 때, `*(ptrarr[index])` 이렇게 괄호를 쳐주지 않아도 되는데, 이는 **`[]` 대괄호 연산자가 `*` 포인터 연산자보다 우선순위가 높기 때문**이다. 

    만약 우선순위가 반대였다면?      

<br>

<br>

## 배열 포인터

+ 배열 포인터 : **배열을 가리키는 포인터**
  포인터 배열이 공간을 특정 개수(들어있는 포인터의 개수)만큼 잡았다면, 배열 포인터는 포인터이기 때문에 **주소를 저장하는 공간 하나(4byte?)가 할당**된다. 

+ `int (*arrptr) [3] ;` 와 같이 선언한다. 

  앞에 타입과 합쳐서 int[3], 즉 **정수형 3개의 공간을 가지는 배열을 가리키는 포인터** arrptr이다. 여기서 괄호를 빼먹으면, `int *arrptr[3]`로, 포인터 배열이 되어버린다. 
  
```c++
  int main(){
      int arr[3] = {1, 2, 3};
      int (*arrptr)[3] = &arr; 
      /*앞에서 &arr은 배열 오브젝트 전체를 나타낸다고 말했다. 배열을 가리키는 포인터인		  배열 포인터에 배열 전체의 주소값을 넣어줘야 하므로 &arr을 사용하는 것 같다.*/
      
      cout << arr << endl;  			// 004FF998 
      cout << arrptr << endl;			// 004FF998 
      
      cout << sizeof(arr) << endl;		// 12
      cout << sizeof(arrptr) << endl;     // 4
      cout << sizeof(*arrptr) << endl;	// 12 ?
      /* arrptr은 배열 전체의 주소인 &arr 값을 가지고 있고, 이에 *연산자를 취하면
      *(&arr) = arr이므로, sizeof(arr) = sizeof(*arrptr) = 12로 동일하다
      */
      
      // 배열포인터의 역참조값 확인
      cout << arrptr << endl;  	// 004FF998 
      cout << *arrptr << endl;	// *arrptr = *(&arr) = arr = 배열의 시작주소
      							// 이므로 동일하게 04FF998 
     
          
      cout << sizeof(*arrptr) << endl;  
      // 해석1
      // *arrptr = *(&arr) = arr이므로, sizeof(arr) = 12 
      // arr 전체의 크기 12
      
      // 해석2
      // arrptr은 배열 전체를 가리키니까 이를 역참조해서 배열 전체의 크기를 구하면 12
      
      cout << sizeof(**arrptr) << endl; 
      // **arrptr = *(*arrptr) = *arr
      // 이는 배열의 이름을 역참조한 것이므로(배열의 이름, 즉 시작주소는 4바이트를 가리키	 // 포인터 상수라 생각할 수 있으므로) 4 
     
  }
```

  + `arrptr`은 배열포인터로, 주소를 저장하는 포인터니 역참조한 결과는 배열을 가리켜야 한다. 배열의 이름은 배열의 시작주소이므로 역참조 결과는 배열의 시작주소이다. 

    `*arrptr` = `*(&arr)` = `arr` = 배열의 시작주소

    따라서, `arrptr`과 `*arrprt`의 **값은 같지만, type이 다르다.** 






+ 배열 포인터를 **2차원 배열과 연관**시켜 생각해보기

  우리는 위에서 `*(ptr+i) = ptr[i]`가 될 수 있음을 보았다. 그럼 `*arrptr`을 `arrptr[0]`으로 확장해서 생각해볼 수 있지 않을까?

  근데, `ptr`은 int 포인터 변수였고, `arrptr`은 크기가 배열 전체인 12바이트 포인터 변수 였다. 따라서, ** `arrptr`을 저렇게 배열처럼 쓰려면 12byte짜리 타입의 공간이 여러개 있는 배열이다**라고 생각해야 한다. 

  ```c++
  int main(){
      
      int ary2d[2][3] = { 1, 2, 3, 10, 20, 30 };
  	cout << ary2d << endl; // 배열의 시작주소 = A, 즉 배열의 첫번째 요소 arr2d[0][0]의 주소값 출력
      cout << *ary2d << endl; // A
  	cout << sizeof(ary2d) << endl; // 배열 전체의 크기 24?
  	cout << sizeof(*ary2d) << endl;  // 12
  	cout << sizeof(**ary2d) << endl; // 4
  
  	// 배열 포인터에 2차원 배열의 이름 대입
  	int(*aryptr)[3] = ary2d;
  	cout << &aryptr << endl; // ? 이는 모르는 값
  	cout << aryptr<< endl;   // A
  	cout << (size_t)aryptr - (size_t)&aryptr << endl; // 이는 원래 모른다.
  
  
  	cout << ary2d << endl; // A
  	cout << ary2d + 1 << endl; // A + 12
  	cout << (size_t)(ary2d + 1) - (size_t)(ary2d) << endl; // 12
      
      cout << ary2d + 1 << endl; // A + 12
      cout << *(ary2d + 1) << endl; // *(ary2d + 1) = art2d[1] = A + 12
  	cout << **(ary2d + 1) << endl; // 10
      cout << sizeof(*(ary2d+1)) << endl; // 12
      cout << sizeof(**(ary2d+1)) << endl; // 4
      cout << (*(art2d+1))[0] << endl; // 10
  }
  ```

  <img src = "https://user-images.githubusercontent.com/31370590/127614984-d421b52e-05ba-4f82-bade-464e1d3abc73.PNG">

  + 여기서, `ary2d[0]` *(ary2d+0) , `ary2d[1]` *( ary2d+1) 은 각 12바이트 배열의 이름이 되는 것이다. 
  + `int(*aryptr)[3] = ary2d;`에서, 배열 포인터에 배열의 이름을 넣었다. 













## 배열을 함수의 매개변수로 사용할 때

+ 배열로 선언된 변수를 함수에 전달하는 경우, 

  + 메모리 관리적인 측면 
    배열은 일반변수보다 더 큰 메모리를 차지하기 때문에
  + 프로그램 실행 속도 측면 
    큰 메모리에 저장된 데이터를 다른 메모리에 복사하는 과정의 시간이 필요하기 때문에 실행시간에 대한 부담 증가
  + 데이터 관리 측면 
    주소가 아닌, 값을 전달하면 프로그램에 동일한 데이터를 가진 메모리가 계속 늘어난다는 뜻으로 '데이터의 중복'을 의미한다. 이를 관리하기 위해서는 내용을 동일하게 유지하는 '데이터 동기화' 작업이 필요

  으로 볼 때, **배열에 저장된 값**이 아닌 ***배열의 주소***를 전달한다. 



```c
#include <stdio.h>

void Test(int temp[1000]) {
    // sizeof 연산자를 사용하여 temp 배열의 크기를 출력한다.
    printf("Array temp size : %d\n", sizeof(temp))
}

void main(){
    int data[1000];
    
    // sizeof 연산자를 사용해 data 배열의 크기를 출력한다.
    printf("Array data size : %d\n", sizeof(data));
    
    // 배열의 시작 주소를 Test 함수의 매개 변수로 전달
    Test(data); // 이는 Test(&data[0]); 와 동일
}
```



```c
Array data size : 4000
Array temp size : 4
```

+ `Test`함수에서 `sizeof(temp)`의 값은 4가 나온다. Test 함수의 `temp` 배열은 컴파일러가 번역할 때 포인터로 변경해서 사용하기 때문이다. Test 함수에 `data` 배열이 매개변수로 전달되면, `data` 배열의 주소가 전달되어 그 포인터값의 크기가 출력된다. 
  따라서, 여기서 `void Test(int temp[1000])`는 `void Test(int *temp)`와 동일하다.

+ 그리고 매개변수 `temp`를 선언할 때 배열 형식으로 선언하더라도 포인터로 사용되기 때문에, temp 변수를 배열로 선언할 때 대괄호([])에는 어떤 숫자를 적든 무시되므로, 보통 대괄호 내에 숙자를 적지 않고 사용하는 것이 일반적이다.

  ```c
  void Test(int temp[])
  ```

  

## 2차원 배열

+ `int arr[3][4]` : 3행 4열의 2차원 배열 

  <img src = "https://user-images.githubusercontent.com/31370590/127348537-84196636-32a6-4b24-98ae-62df611c5cb4.PNG" width = "500" height = "100">

+ 배열의 base 주소는 `arr[0][0]`이 된다. 

  `arr[0][1]`의 주소 = base + 배열의 한 원소의 크기

  `arr[1][1]`의 주소 = base + 1(1열) * 4(총 4행) * 4(sizeof int) + 1(1행) * 4(sizeof int)

+ 이를 일반화하면

  r행 c열의 2차원 배열 `arr[r][c]`가 있다고 하자.

  `arr[i][j]`의 주소는? arr[i] + (j * sizeof datatype)

  => arr[i] = base + c * i * datatype, base = `arr[0][0]`



## 배열의 표기법

+ 1차원 배열의 표기법을 1차원 포인터로 변환

  `data[1] = 3;` => `*(data+1) = 3;`

  > 위의 식의 각 항에 & 연산자를 적용용하면
  >
  > &data[1] = data +  1 임을 알 수 있다.
  >
  > 즉, 배열의 이름 arr에서, arr + i = &arr[i] 임을 알 수 있다. 



+ 2차원 배열의 표기법을 2차원 포인터로 변환

  `char data[3][4];`

  `data[1][2] = 5;` => `*( *(data+1) + 2 ) = 5;` 

  + A = data[1]로 치환하면,  data[1] = *(data+1)

    `A[2] = 5;` => `*(A+2) = 5;` => `*(data[1] + 2) = 5;` 

    ​	=> `*( *(data+1) + 2) = 5;` 

     

+ 위의 내용을 정리하면, 2차원으로 선언된 배열은 아래와 같이 세 가지 형태로 표기가 가능하다

  `char data[3][5]`

  1. `data[1][2]= 5;`
  2. `*(data[1] + 2) = 5;`
  3. `*( *(data+1) + 2 ) = 5;`



+ 여기에 추가로, 2번과 반대로 배열의 1차원쪽(column)을 배열 표기로 두고, 2차원 쪽(row)을 포인터 표기로 바꾼 형태도 있다.
  4. `(*(data+1))[2] = 5;`



+ 하지만, 여기서 괄호를 생략하고 `*(data+1)[2] = 5;` 로 표기하면 의미가 달라진다

  ```c++
  *(data + 1)[2] = 5;
  *A[2] = 5;			// data+1을 A로 치환
  **(A+2) = 5;		// A[2] 부분을 포인터 표기로 변경
  **(data+1+2) = 5;	// A를 다시 data+1로 복원합니다.
  **(data+3) = 5;		// +연산을 정리해서 수식완성
  ```

  2차원 포인터 표기법으로 변경해보니 우리가 원했던 표현인 `*( *(data+1)+2 ) = 5;`와는 맣이 다르다는 것을 알 수 있다. 

  그럼 `**(data+3) = 5;`가 어떤 위치를 나타내는지 확인해보자.

  ```c++
  **(data+3) = 5;
  *( *(data+3) + 0 ) = 5; // 생략된 +0을 복원
  data[3][0] = 5;			// 다시 배열 표기로 변경해서 위치를 확인
  ```

  data 배열은 `char data[3][5]`와 같이 선언되었기 때문에 2차원 항목(row)은 0~2까지만 접근이 가능한데 `data[3][0]`에 접근했으므로 실제 data 배열의 영역을 벗어나게 됩니다. 따라서 5값은 배열 영역을 벗어난 곳에 저장되기 때문에 프로그램이 실행되다가 메모리 오휴가 발생하게 되는 것입니다. 





## 표기법이 동일하다고 구조가 동일하지는 않다

```c++
dat[1][2] = 5;
```

```c++
*( *(data+1)+2 ) = 5;
```

 이러한 2가지 표기법, 2차원 배열과 2차원 포인터가 동일한 구조를 가지는 것은 아니다.

```c++
char data[2][3]
```

<img src = "https://user-images.githubusercontent.com/31370590/127454313-f2d4e3ae-0b0b-4095-b808-91d837af2623.PNG">

+ data 배열은 메모리에 다음과 같이 배열될 것이다. 표기는 2차원 형태이지만 메모리 구성은 1차원 배열인 char data[6]과 동일한 형태가 된다. 즉, **data[0]과 data[1]이 서로 나누어지지 않고 연결되어 있는 구조로 되어 있기 때문에 data[1]의 주소를 저장하기 위한 추가적이 메모리가 필요 없습니다.** 
+ 그리고 data[1]에 있는 항목들에 접근할 때도 `data[0]`의 주소로도 얼만든지 접근이 가능하다.
  + `data[1][0]` = `data[0][3]`
  + `data[1][1]` = `data[0][4]`
  + `data[1][2]` = `data[0][5]`



하지만 포인터는 그렇지 않다. 아래와 같이 2차원 포인터가 선언되어 있다면

```c++
char **P;
```

<img src = "https://user-images.githubusercontent.com/31370590/127460976-b732ba01-2b11-4393-906e-2df0751ee3b4.PNG">

+ 이 포인터는 **다음 차원으로 이동하기 위해서 4바이트 크기의 메모리에 주소가 저장되어 있어야** 한다. 따라서 `char data[2][3];` 처럼 6바이트 크기의 메모리를 사용하고 싶다면 아래와 같이 동적으로 메모리를 할당해야 하기 때문에  2차원 배열과 메모리 구조가 완전히 달라진다.

+ 즉, 4개의 메모리 블록은 연속된 위치에 존재하지 않기 때문에 서로의 메모리 블록을 포인터로 연결해야 하는 구조이다. 

  따라서 포인터 p는 `*(p+1)`과 `*(p+2)`로 사용가능한 2칸으로 표시된 사각형(8byte)의 메모리 블록의 시작 주소를 기억하고 있다.

  그리고 2칸으로 표시된 각각의 1차원 포인터는 3칸으로 그려진 사각형(3byte)의 시작 주소를 기억하고 있는 구조이다.

+ 결국 2차원 포인터는 **2차원 배열에는 존재하지 않는 12바이트의 메모리(p, *(p+0), *(p+1)에 해당하는 메모리)를 추가로 필요**로 하며 실제로 사용할 6바이트의 메모리는 3바이트씩 별개의 메모리 그룹으로 나누어져 있기 때문에 주소가 연속적으로 나열되지 않는다. 

+ 따라서, 아래와 같이 주소를 대입하는 것은 오류가 발생한다.

  ```c++
  char data[2][3];
  char **p;
  p = data;         // 오류 발생! 두 변수의 자료형이 일치하지 않음 
  ```

  









## 참고

+ [지식나눔으로 누구에게나 따뜻한 블로그](https://blog.naver.com/tipsware/221329354634)
+ [양햄찌가 만드는 세상](https://jhnyang.tistory.com/344)
